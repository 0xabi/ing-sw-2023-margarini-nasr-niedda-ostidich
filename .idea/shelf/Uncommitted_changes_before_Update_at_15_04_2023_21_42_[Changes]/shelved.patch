Index: src/main/java/it/polimi/ingsw/model/CommonGoal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\r\n\r\nimport it.polimi.ingsw.model.exceptions.NoPlayerNumberException;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * <p>The class is abstract and have concrete common goals that inherits itself, overriding check method.</p>\r\n * <p>If check method returns true, points are assigned to the player, popping points from the scoring token stack.\r\n * A map remembers who has already taken the points, in order to not call the check method again on him.\r\n * Different player number's game have different scoring token stacks.</p>\r\n * @author Francesco Ostidich\r\n */\r\npublic abstract class CommonGoal {\r\n\r\n    private final ScoringTokenStack tokens;\r\n\r\n    private final Map<Integer, Player> givenPlayers;\r\n\r\n\r\n    /**\r\n     * <p>Class constructor.</p>\r\n     * <p>It generates tokens stack and given players map.</p>\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @param playerNumber is the number of player of the game match\r\n     */\r\n    public CommonGoal(int playerNumber) {\r\n        tokens = new ScoringTokenStack(playerNumber);\r\n        givenPlayers = new HashMap<>();\r\n    }\r\n\r\n    /**\r\n     * Getter for given players map.\r\n     *\r\n     * @return given players map\r\n     * @author Francesco Ostidich\r\n     */\r\n    public Map<Integer, Player> getGivenPlayers() {\r\n        return givenPlayers;\r\n    }\r\n\r\n    /**\r\n     * <p>Common goals implemented specifically in concrete subclasses</p>\r\n     * <p>Checks if player's shelf got the common goal.</p>\r\n     *\r\n     * @param shelf is the players shelf to check to\r\n     * @return boolean true if check succeeds.\r\n     * @author Francesco Ostidich\r\n     */\r\n    public abstract boolean check(Shelf shelf);\r\n\r\n    /**\r\n     * Assigns points to the player if check is true.\r\n     *\r\n     * @param player is the player to assign points to\r\n     * @author Francesco Ostidich\r\n     */\r\n    public void assignPoints(@NotNull Player player) {\r\n        player.addPoints(tokens.pop());\r\n    }\r\n\r\n}\r\n
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/CommonGoal.java b/src/main/java/it/polimi/ingsw/model/CommonGoal.java
--- a/src/main/java/it/polimi/ingsw/model/CommonGoal.java	
+++ b/src/main/java/it/polimi/ingsw/model/CommonGoal.java	
@@ -3,8 +3,7 @@
 import it.polimi.ingsw.model.exceptions.NoPlayerNumberException;
 import org.jetbrains.annotations.NotNull;
 
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
 
 /**
  * <p>The class is abstract and have concrete common goals that inherits itself, overriding check method.</p>
@@ -62,4 +61,6 @@
         player.addPoints(tokens.pop());
     }
 
+
+
 }
Index: src/main/java/it/polimi/ingsw/model/GameModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.model;\r\n\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * GameModel must bee the only class which, via an interface, talks to the controller.\r\n * It collects all the method from another classes the composes a player turn, besides generation and conclusion of a game match.\r\n * GameModel.java is itself enough to have the match keeping going.\r\n * In the game generation phase the GameModel constructor constructs directly or indirectly the necessary objects\r\n * (it also makes sure to have different common and personal goals); eventually it starts a turns cycle, repeatedly until\r\n * a shelf is full (optional value in Board.java). At the end points are calculated and sent to the controller: points\r\n * are mapped with players' names (in the scenario of a tie game, the controller is able to get a list of player's name\r\n * to get knowledge of the turns progression and consequently to announce a winner).\r\n *\r\n * @author Francesco Ostidich\r\n */\r\npublic class GameModel {\r\n\r\n    private final Board board;\r\n\r\n    private CommonGoal commonGoal1;\r\n\r\n    private CommonGoal commonGoal2;\r\n\r\n    private final List<Player> players = new LinkedList<>();\r\n\r\n    /**\r\n     * Constructs both the common goals, while being sure they are different.\r\n     *\r\n     * @author Francesco Ostidich\r\n     */\r\n    private void commonGoalConstructor(int playerNumber) {\r\n        commonGoal1 = CommonGoalFactory.getCommonGoal(playerNumber);\r\n        CommonGoal commonGoalTemp = CommonGoalFactory.getCommonGoal(playerNumber);\r\n        while(commonGoalTemp.equals(commonGoal1)) {\r\n            commonGoalTemp = CommonGoalFactory.getCommonGoal(playerNumber);\r\n        }\r\n        commonGoal2 = commonGoalTemp;\r\n    }\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @param names is the list with the players names got from the controller, used for construct the player objects\r\n     */\r\n    public GameModel(@NotNull List<String> names, int playerNumber) {\r\n        board = new Board(names.size());\r\n        commonGoalConstructor(playerNumber);\r\n        playerListConstructor(names);\r\n    }\r\n\r\n    /**\r\n     * Constructs all the player, sorting out different numbers in order to get different personal goals for each one.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @param names is the list with the players names got from the controller, used for construct the player objects\r\n     */\r\n    private void playerListConstructor(@NotNull List<String> names) {\r\n        Random random = new Random();\r\n        Set<Integer> personalGoalNumbersSet = new HashSet<>();\r\n        while(personalGoalNumbersSet.size() < names.size())\r\n            personalGoalNumbersSet.add(random.nextInt(1, 13));\r\n        Stack<Integer> personalGoalNumbers = new Stack<>();\r\n        Set<Boolean> dummy = personalGoalNumbersSet.stream().map(personalGoalNumbers::add).collect(Collectors.toSet());\r\n\r\n        int playerNumber = names.size();\r\n        for(int i = 0; i < playerNumber; i++)\r\n            players.add(new Player(names.get(random.nextInt(0, names.size())), personalGoalNumbers.pop()));\r\n    }\r\n\r\n    /**\r\n     * <p>For each player in the game, the method lets him play a single turn.</p>\r\n     * <p>Order of a turn actions: <br>\r\n     * - player picks tiles <br>\r\n     * - player choose order <br>\r\n     * - player insert tiles in his shelf <br>\r\n     * - common goals checked <br>\r\n     * - common goals points assigned <br>\r\n     * - check if the board is to be filled <br>\r\n     * - if the optional in Board.java is present:<br>\r\n     * &#32&#32&#32- checks if the player's shelf is filled<br>\r\n     * &#32&#32&#32- assigns points of the end game token if its filled</p>\r\n     *\r\n     * @author Francesco Ostidich\r\n     */\r\n    public void turnCycle() {\r\n        List<Coordinates> choiceCoordinates;\r\n        List<Tile> choiceTiles = new LinkedList<>();\r\n\r\n        for(Player player: players) {\r\n\r\n            choiceCoordinates = player.pickTiles(board);\r\n            for(Coordinates coordinates: choiceCoordinates)\r\n                choiceTiles.add(board.getTileInBoard(coordinates));\r\n            while(!board.selectTiles(choiceCoordinates)) {\r\n                choiceCoordinates = player.pickTiles(board);\r\n                choiceTiles.clear();\r\n                for(Coordinates coordinates: choiceCoordinates)\r\n                    choiceTiles.add(board.getTileInBoard(coordinates));\r\n            }\r\n\r\n            player.insertTiles(choiceTiles);\r\n\r\n            if(!commonGoal1.getGivenPlayers().containsValue(player) &&\r\n                    commonGoal1.check(player.getShelf())) {\r\n                commonGoal1.assignPoints(player);\r\n            }\r\n            if(!commonGoal2.getGivenPlayers().containsValue(player) &&\r\n                    commonGoal2.check(player.getShelf())) {\r\n                commonGoal2.assignPoints(player);\r\n            }\r\n\r\n            board.checkToRefill();\r\n\r\n            if(player.getShelf().isFull()) {\r\n                board.getEndGameToken().ifPresent(endGameToken -> {\r\n                    endGameToken.assignPoints(player);\r\n                    board.setEndGameToken(Optional.empty());\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks for a players connection in order to continue the turn cycle. Otherwise, the turn should be played randomly,\r\n     * or skipped if no action has been taken yet.\r\n     *\r\n     * @param player is the player to check connection of\r\n     * @return boolean value true if the player is still connected and playing\r\n     */\r\n    @SuppressWarnings(\"SameReturnValue\")\r\n    private boolean checkForPlayerConnection(Player player) {\r\n        //makes sure the player is still connected and playing\r\n        //TODO method code is to be written when controller is understood\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * <p>When the turn cycle is finished, and at least a shelf is filled, points are being processed and sent to the controller\r\n     * in a map.</p>\r\n     * <p>Order of actions to calculate points:<br>\r\n     * - personal goals are calculated<br>\r\n     * - adjacent tiles goals are calculated</p>\r\n     * <p>Controller should call method GameModel.getTurnCycleOrder() if there's a tie scenario, in order to\r\n     * choose a winner</p>\r\n     * @author Francesco Ostidich\r\n     * @return the map with players' names as keys and respective points as values\r\n     */\r\n    public Map<String, Integer> calculatePoints() {\r\n        Map<String, Integer> playersPoints = new HashMap<>();\r\n        for(Player player: players) {\r\n            player.getPersonalGoal().assignPoints(player);\r\n            AdjacentTilesGoal.assignPoints(player);\r\n            playersPoints.put(player.getName(), player.getPoints());\r\n        }\r\n        return playersPoints;\r\n    }\r\n\r\n    /**\r\n     * <p>Used in case of a tie</p>\r\n     * <p>Returns the list of players' names based on the turn cycle order</p>\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return the list of players' names sorted as the turn cycle was played\r\n     */\r\n    public List<String> getTurnCycleOrder() {\r\n        List<String> namesOrder = new LinkedList<>();\r\n        for(Player player: players) {\r\n            namesOrder.add(player.getName());\r\n        }\r\n        return namesOrder;\r\n    }\r\n\r\n}\r\n
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/model/GameModel.java b/src/main/java/it/polimi/ingsw/model/GameModel.java
--- a/src/main/java/it/polimi/ingsw/model/GameModel.java	
+++ b/src/main/java/it/polimi/ingsw/model/GameModel.java	
@@ -96,7 +96,7 @@
             choiceCoordinates = player.pickTiles(board);
             for(Coordinates coordinates: choiceCoordinates)
                 choiceTiles.add(board.getTileInBoard(coordinates));
-            while(!board.selectTiles(choiceCoordinates)) {
+            while(board.selectTiles(choiceCoordinates)!=null) {
                 choiceCoordinates = player.pickTiles(board);
                 choiceTiles.clear();
                 for(Coordinates coordinates: choiceCoordinates)
