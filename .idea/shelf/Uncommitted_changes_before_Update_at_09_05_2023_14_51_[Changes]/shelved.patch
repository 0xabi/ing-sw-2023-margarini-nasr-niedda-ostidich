Index: src/main/java/it/polimi/ingsw/client/view/CLI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.client.view;\r\n\r\nimport it.polimi.ingsw.resources.*;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * CLI class is to implement GameView UI abstract class.\r\n * Going in depth, methods called here print something and open a scanner to retrieve returnable information,\r\n * to be passed to the controller.\r\n * Checks to see if scanned data is valid is implemented here.\r\n *\r\n * @author Francesco Ostidich\r\n */\r\npublic class CLI extends GameClientView {\r\n\r\n    private String chatMessage = \"\";\r\n\r\n    private String dataMessage = \"\";\r\n\r\n    private final Thread scannerThread;\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @author Francesco Ostidich\r\n     */\r\n    public CLI(String network) {\r\n        super(network);\r\n        scannerThread = new Thread(this::scan);\r\n        scannerThread.start();\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void start() {\r\n        System.out.println(\"\"\"\r\n\r\n                ___  ___      _____ _          _  __ _     \\s\r\n                |  \\\\/  |     /  ___| |        | |/ _(_)    \\s\r\n                | .  . |_   _\\\\ `--.| |__   ___| | |_ _  ___\\s\r\n                | |\\\\/| | | | |`--. \\\\ '_ \\\\ / _ \\\\ |  _| |/ _ \\\\\r\n                | |  | | |_| /\\\\__/ / | | |  __/ | | | |  __/\r\n                \\\\_|  |_/\\\\__, \\\\____/|_| |_|\\\\___|_|_| |_|\\\\___|\r\n                         __/ |                             \\s\r\n                        |___/                              \\s\r\n\r\n\r\n\r\n\r\n                Loading...\"\"\");\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void chooseIPAddress() {\r\n        String scannedIP = playerMessage(\"Choose IP address:\");\r\n        while(!InputFormatChecker.isIPAddress(scannedIP)) {\r\n            scannedIP = playerMessage(\"Wrong input!\\nChoose IP address:\");\r\n        }\r\n        getClientController().update(new Event(EventID.CHOOSE_IP_ADDRESS, scannedIP));\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void choosePlayerName() {\r\n        String scannedIP = playerMessage(\"Choose player name:\");\r\n        while(scannedIP.isBlank()) {\r\n            scannedIP = playerMessage(\"Wrong input!\\nChoose player name:\");\r\n        }\r\n        getClientController().update(new Event(EventID.CHOOSE_PLAYER_NAME, scannedIP));\r\n    }\r\n\r\n\r\n    /**\r\n     * @author Abdullah Nasr\r\n     */\r\n    @Override\r\n    public void chooseNewOrJoin() {\r\n        String answer = playerMessage(\"Type [new] to create new game or [join] to join an existing game:\");\r\n        answer = answer.trim().toLowerCase();\r\n\r\n        while(!answer.equals(\"new\") && !answer.equals(\"join\"))\r\n        {\r\n            answer = playerMessage(\"Wrong input!\\nType [new] to create new game or [join] to join an existing game:\");\r\n            answer=answer.trim().toLowerCase();\r\n        }\r\n\r\n        getClientController().update(new Event(EventID.CHOOSE_NEW_OR_JOIN, answer));\r\n    }\r\n\r\n\r\n    /**\r\n     * @author Abdullah Nasr\r\n     */\r\n    @Override\r\n    public void chooseNewGameName() {\r\n        String gameName = playerMessage(\"Choose a new game name:\");\r\n        while(gameName.isBlank())\r\n        {\r\n            gameName = playerMessage(\"Wrong input!\\nChoose a new game name:\");\r\n        }\r\n\r\n        getClientController().update(new Event(EventID.CHOOSE_NEW_GAME_NAME, gameName));\r\n    }\r\n\r\n    /**\r\n     * @author Abdullah Nasr\r\n     */\r\n    @Override\r\n    public void chooseNewGamePlayerNumber() {\r\n        Integer numPlayer;\r\n        String input =  playerMessage(\"Choose the number of players [max \"+InputFormatChecker.getMaxPlayer()+\" players\"+\"]:\");\r\n        numPlayer = InputFormatChecker.getNumFromString(input);\r\n\r\n        while(numPlayer==null||numPlayer<2||numPlayer>InputFormatChecker.getMaxPlayer())\r\n        {\r\n            input =  playerMessage(\"Please insert a valid number of player!\\nChoose the number of the player:\");\r\n            numPlayer = InputFormatChecker.getNumFromString(input);\r\n        }\r\n\r\n        getClientController().update(new Event(EventID.CHOOSE_NEW_GAME_PLAYER_NUMBER, numPlayer));\r\n    }\r\n\r\n\r\n    /**\r\n     * @author Abdullah Nasr\r\n     */\r\n    @Override\r\n    public void notifyGameHasStared() {\r\n        playerMessage(\"Game started!\\n\");\r\n    }\r\n\r\n    /**\r\n     * @author Abdullah Nasr\r\n     */\r\n    @Override\r\n    public void chooseGameRoom(List<GameRoom> rooms) {\r\n\r\n        String gameRoomTable = InputFormatChecker.getTableGameRoom(rooms);\r\n        String answer;\r\n\r\n        answer = playerMessage(gameRoomTable+\"\\nType the room name or insert the number of row: \");\r\n        while(!InputFormatChecker.isGameRoomValid(gameRoomTable,rooms))\r\n        {\r\n            answer = playerMessage(gameRoomTable+\"\\nInvalid game room!\\nType the room name or insert the number of row: \");\r\n        }\r\n\r\n        getClientController().update(new Event(EventID.CHOOSE_GAME_ROOM, answer));\r\n    }\r\n\r\n    @Override\r\n    public void pickTiles(int availablePickNumber) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void chooseOrder(List<Tile> selection) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void chooseColumn() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void playerIsPlaying(String playerName) {\r\n        System.out.println(playerName + \"is currently playing his turn\");\r\n    }\r\n\r\n    @Override\r\n    public void assignCommonGoalPoints(String playerName, int token) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void assignPersonalGoalPoints(Map<String, Integer> points) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void assignAdjacentGoalPoints(Map<String, Integer> points) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void announceWinner(String winnerName, Map<String, Integer> points) {\r\n    }\r\n\r\n    @Override\r\n    public void disconnected() {\r\n        System.out.println(\"Disconnected from server. Trying to reconnect...\");\r\n    }\r\n\r\n    @Override\r\n    public void justScanChat() {\r\n        while(chatMessage == null) {\r\n            try {\r\n                //noinspection BusyWait\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException ignored) {\r\n            }\r\n        }\r\n        String temp = chatMessage;\r\n        chatMessage = null;\r\n        getClientController().update(new Event(EventID.JUST_SCAN_CHAT, temp));\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void justPrintChat(String message) {\r\n        System.out.println(message);\r\n    }\r\n\r\n    /**\r\n     * Scanner is always open on separated thread.\r\n     * If message written is of chat type it's written in chatMessage, otherwise in dataMessage.\r\n     *\r\n     * @author Francesco Ostidich\r\n     */\r\n    private void scan() {\r\n        String prefix = \"/msg \";\r\n        Scanner scanner = new Scanner(System.in);\r\n        while(true) {\r\n            String temp = scanner.nextLine();\r\n            if(temp.startsWith(prefix))\r\n                chatMessage = temp.substring(prefix.length());\r\n            else\r\n                dataMessage = temp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method returns player inserted string (null if timout time is reached).\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @param timeOut is the timeout number in second\r\n     * @param inputMessage is the message to print posting the requested data\r\n     * @return player's written data\r\n     */\r\n    private String playerMessage(String inputMessage, int timeOut) {\r\n        int i = timeOut + 1;\r\n        System.out.print(inputMessage + \" \");\r\n        dataMessage = null;\r\n        while(dataMessage == null && i > 0) {\r\n            try {\r\n                //noinspection BusyWait\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException ignored) {\r\n            } finally {\r\n                i--;\r\n                System.out.print(i + \" \");\r\n            }\r\n        }\r\n        System.out.println();\r\n        String temp = dataMessage;\r\n        dataMessage = null;\r\n        return temp;\r\n    }\r\n\r\n    /**\r\n     * Method returns player inserted string (no timeout is waited).\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @param  inputMessage is the message to print posting the requested data\r\n     * @return player's written data\r\n     */\r\n    private String playerMessage(String inputMessage) {\r\n        System.out.print(inputMessage + \" \");\r\n        dataMessage = null;\r\n        while(dataMessage == null) {\r\n            try {\r\n                //noinspection BusyWait\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException ignored) {\r\n            }\r\n        }\r\n        System.out.println();\r\n        String temp = dataMessage;\r\n        dataMessage = null;\r\n        return temp;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/client/view/CLI.java b/src/main/java/it/polimi/ingsw/client/view/CLI.java
--- a/src/main/java/it/polimi/ingsw/client/view/CLI.java	(revision 9039822922184e9b3ec12a41c48f7dae0dfd9a26)
+++ b/src/main/java/it/polimi/ingsw/client/view/CLI.java	(date 1683628675387)
@@ -61,7 +61,7 @@
     @Override
     public void chooseIPAddress() {
         String scannedIP = playerMessage("Choose IP address:");
-        while(!InputFormatChecker.isIPAddress(scannedIP)) {
+        while (!InputFormatChecker.isIPAddress(scannedIP)) {
             scannedIP = playerMessage("Wrong input!\nChoose IP address:");
         }
         getClientController().update(new Event(EventID.CHOOSE_IP_ADDRESS, scannedIP));
@@ -73,7 +73,7 @@
     @Override
     public void choosePlayerName() {
         String scannedIP = playerMessage("Choose player name:");
-        while(scannedIP.isBlank()) {
+        while (scannedIP.isBlank()) {
             scannedIP = playerMessage("Wrong input!\nChoose player name:");
         }
         getClientController().update(new Event(EventID.CHOOSE_PLAYER_NAME, scannedIP));
@@ -88,10 +88,9 @@
         String answer = playerMessage("Type [new] to create new game or [join] to join an existing game:");
         answer = answer.trim().toLowerCase();
 
-        while(!answer.equals("new") && !answer.equals("join"))
-        {
+        while (!answer.equals("new") && !answer.equals("join")) {
             answer = playerMessage("Wrong input!\nType [new] to create new game or [join] to join an existing game:");
-            answer=answer.trim().toLowerCase();
+            answer = answer.trim().toLowerCase();
         }
 
         getClientController().update(new Event(EventID.CHOOSE_NEW_OR_JOIN, answer));
@@ -104,8 +103,7 @@
     @Override
     public void chooseNewGameName() {
         String gameName = playerMessage("Choose a new game name:");
-        while(gameName.isBlank())
-        {
+        while (gameName.isBlank()) {
             gameName = playerMessage("Wrong input!\nChoose a new game name:");
         }
 
@@ -118,12 +116,11 @@
     @Override
     public void chooseNewGamePlayerNumber() {
         Integer numPlayer;
-        String input =  playerMessage("Choose the number of players [max "+InputFormatChecker.getMaxPlayer()+" players"+"]:");
+        String input = playerMessage("Choose the number of players [max " + InputFormatChecker.getMaxPlayer() + " players" + "]:");
         numPlayer = InputFormatChecker.getNumFromString(input);
 
-        while(numPlayer==null||numPlayer<2||numPlayer>InputFormatChecker.getMaxPlayer())
-        {
-            input =  playerMessage("Please insert a valid number of player!\nChoose the number of the player:");
+        while (numPlayer == null || numPlayer < 2 || numPlayer > InputFormatChecker.getMaxPlayer()) {
+            input = playerMessage("Please insert a valid number of player!\nChoose the number of the player:");
             numPlayer = InputFormatChecker.getNumFromString(input);
         }
 
@@ -148,10 +145,9 @@
         String gameRoomTable = InputFormatChecker.getTableGameRoom(rooms);
         String answer;
 
-        answer = playerMessage(gameRoomTable+"\nType the room name or insert the number of row: ");
-        while(!InputFormatChecker.isGameRoomValid(gameRoomTable,rooms))
-        {
-            answer = playerMessage(gameRoomTable+"\nInvalid game room!\nType the room name or insert the number of row: ");
+        answer = playerMessage(gameRoomTable + "\nType the room name or insert the number of row: ");
+        while (!InputFormatChecker.isGameRoomValid(gameRoomTable, rooms)) {
+            answer = playerMessage(gameRoomTable + "\nInvalid game room!\nType the room name or insert the number of row: ");
         }
 
         getClientController().update(new Event(EventID.CHOOSE_GAME_ROOM, answer));
@@ -203,7 +199,7 @@
 
     @Override
     public void justScanChat() {
-        while(chatMessage == null) {
+        while (chatMessage == null) {
             try {
                 //noinspection BusyWait
                 Thread.sleep(1000);
@@ -232,9 +228,9 @@
     private void scan() {
         String prefix = "/msg ";
         Scanner scanner = new Scanner(System.in);
-        while(true) {
+        while (true) {
             String temp = scanner.nextLine();
-            if(temp.startsWith(prefix))
+            if (temp.startsWith(prefix))
                 chatMessage = temp.substring(prefix.length());
             else
                 dataMessage = temp;
@@ -244,16 +240,16 @@
     /**
      * Method returns player inserted string (null if timout time is reached).
      *
-     * @author Francesco Ostidich
-     * @param timeOut is the timeout number in second
+     * @param timeOut      is the timeout number in second
      * @param inputMessage is the message to print posting the requested data
      * @return player's written data
+     * @author Francesco Ostidich
      */
     private String playerMessage(String inputMessage, int timeOut) {
         int i = timeOut + 1;
         System.out.print(inputMessage + " ");
         dataMessage = null;
-        while(dataMessage == null && i > 0) {
+        while (dataMessage == null && i > 0) {
             try {
                 //noinspection BusyWait
                 Thread.sleep(1000);
@@ -272,14 +268,14 @@
     /**
      * Method returns player inserted string (no timeout is waited).
      *
-     * @author Francesco Ostidich
-     * @param  inputMessage is the message to print posting the requested data
+     * @param inputMessage is the message to print posting the requested data
      * @return player's written data
+     * @author Francesco Ostidich
      */
     private String playerMessage(String inputMessage) {
         System.out.print(inputMessage + " ");
         dataMessage = null;
-        while(dataMessage == null) {
+        while (dataMessage == null) {
             try {
                 //noinspection BusyWait
                 Thread.sleep(1000);
Index: src/main/java/it/polimi/ingsw/client/clientController/GameClientController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.client.clientController;\r\n\r\nimport it.polimi.ingsw.client.clientNetwork.GameClientNetwork;\r\nimport it.polimi.ingsw.resources.*;\r\nimport it.polimi.ingsw.resources.interfaces.ClientController;\r\nimport it.polimi.ingsw.resources.interfaces.ClientNetwork;\r\nimport it.polimi.ingsw.resources.interfaces.ClientView;\r\nimport it.polimi.ingsw.resources.interfaces.ServerController;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * The game view controller is to receive messages from the network handler, and consequentially call methods on the view.\r\n * On the other side it has to retrieve events and data from the view and package, in order to be sent to the server controller\r\n * to be processed.\r\n *\r\n * @author Francesco Ostidich\r\n */\r\npublic class GameClientController implements ClientController {\r\n\r\n    private ServerController server;\r\n\r\n    private final ClientView view;\r\n\r\n    private static ClientNetwork clientNetwork;\r\n\r\n    private String playerName;\r\n\r\n    private int newRoomPlayerNumber;\r\n\r\n    private List<Tile> orderChosen;\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @author Francesco Ostidich\r\n     */\r\n    public GameClientController(@NotNull ClientView view, String network) {\r\n        clientNetwork = new GameClientNetwork(network);\r\n        this.view = view;\r\n        view.start();\r\n    }\r\n\r\n    /**\r\n     * Used to pass method request answer to the controller from the view.\r\n     * It contains switch cases based on event type.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @param evt is the event information\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public void update(@NotNull Event evt) {\r\n        switch(evt.eventName()) {\r\n            case START -> view.choosePlayerName();\r\n            case CHOOSE_PLAYER_NAME -> {\r\n                this.playerName = (String) evt.value();\r\n                view.chooseIPAddress();\r\n            }\r\n            case CHOOSE_IP_ADDRESS -> {\r\n                server = clientNetwork.connect((String) evt.value(), playerName, this);\r\n                view.chooseNewOrJoin();\r\n            }\r\n            case CHOOSE_NEW_OR_JOIN -> {\r\n                if(evt.value().equals(\"new\")) view.chooseNewGamePlayerNumber();\r\n                else server.askForRooms(new Message(playerName, MessageID.ASK_FOR_ROOMS));\r\n            }\r\n            case CHOOSE_NEW_GAME_PLAYER_NUMBER -> {\r\n                newRoomPlayerNumber = (int) evt.value();\r\n                view.chooseNewGameName();\r\n            }\r\n            case CHOOSE_NEW_GAME_NAME -> {\r\n                if(evt.value().equals(\"back\")) view.chooseNewOrJoin();\r\n                server.createNewRoom(new Message(playerName, MessageID.CREATE_NEW_ROOM, evt.value(), newRoomPlayerNumber));\r\n            }\r\n            case CHOOSE_GAME_ROOM -> {\r\n                if(evt.value().equals(\"refresh\")) server.askForRooms(new Message(playerName, MessageID.ASK_FOR_ROOMS));\r\n                else if(evt.value().equals(\"back\")) view.chooseNewOrJoin();\r\n                else server.joinRoom(new Message(playerName, MessageID.JOIN_ROOM, evt.value()));\r\n            }\r\n            case PICK_TILES -> server.pickTilesRequest(new Message(playerName, MessageID.PICK_TILES_REQUEST, evt.value()));\r\n            case CHOOSE_ORDER -> {\r\n                orderChosen = (List<Tile>) evt.value();\r\n                view.chooseColumn();\r\n            }\r\n            case CHOOSE_COLUMN -> server.insertTilesRequest(new Message(playerName, MessageID.INSERT_TILE_REQUEST, orderChosen, evt.value()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void restart() {\r\n        view.start();\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void roomNameNotAvailable() {\r\n        view.chooseNewGameName();\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void disconnectedFromServer() {\r\n        view.disconnected();\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    @SuppressWarnings({\"unchecked\", \"StatementWithEmptyBody\"})\r\n    public void showRooms(@NotNull Message msg) {\r\n        if(!msg.playerName().equals(playerName) ||\r\n                msg.messageID() != MessageID.SHOW_ROOMS ||\r\n                !(msg.content() instanceof List<?>)) return;\r\n        for(Object gameRoom: (List<?>) msg.content()) {}\r\n        try{\r\n            view.chooseGameRoom((List<GameRoom>) msg.content());\r\n        } catch (ClassCastException ignored) {}\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void showPersonalRoom(@NotNull Message msg) {\r\n        if(!msg.playerName().equals(playerName) ||\r\n                msg.messageID() != MessageID.SHOW_PERSONAL_ROOM ||\r\n                !(msg.content() instanceof GameRoom)) return;\r\n        view.updateGameRoom((GameRoom) msg.content());\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    @SuppressWarnings({\"unchecked\", \"DuplicatedCode\", \"StatementWithEmptyBody\"})\r\n    public void notifyGameHasStarted(@NotNull Message msg) {\r\n        if(!msg.playerName().equals(playerName) ||\r\n                msg.messageID() != MessageID.NOTIFY_GAME_HAS_STARTED) return;\r\n        Object[] data = msg.contents();\r\n        try {\r\n            for(Object string: ((Map<String, Integer>) data[0]).keySet()) {}\r\n            for(Object integer: ((Map<String, Integer>) data[0]).values()) {}\r\n            view.setGameParameters((Map<String, Integer>) data[0]);\r\n            for(Object string: (List<String>) data[1]) {}\r\n            view.turnCycleOrder((List<String>) data[1]);\r\n            for(Object tile: (Tile[][]) data[2]) {}\r\n            view.updateBoard((Tile[][]) data[2]);\r\n            for(Object tile: ((Map<Tile, Integer>) data[3]).keySet()) {}\r\n            for(Object integer: ((Map<Tile, Integer>) data[3]).values()) {}\r\n            view.updateBag((Map<Tile, Integer>) data[3]);\r\n            for(Object integer: (Stack<Integer>) data[4]) {}\r\n            view.updateCommonGoal1TokenStack((Stack<Integer>) data[4]);\r\n            view.updateCommonGoal2TokenStack((Stack<Integer>) data[4]);\r\n            Map<String, Integer> playerPoints = new HashMap<>();\r\n            for(String player: (List<String>)data[1])\r\n                playerPoints.put(player, 0);\r\n            view.updatePlayerPoints(playerPoints);\r\n            Tile[][] shelf = new Tile[((Map<String, Integer>) data[0]).get(\"shelfColumnNumber\")][((Map<String, Integer>) data[0]).get(\"shelfRowNumber\")];\r\n            Map<String, Tile[][]> playerShelves = new HashMap<>();\r\n            for(String player: (List<String>)data[1])\r\n                playerShelves.put(player, shelf);\r\n            view.updatePlayerShelves(playerShelves);\r\n            List<Integer> personalGoal = new LinkedList<>();\r\n            personalGoal.add((Integer) data[5]);\r\n            view.givePersonalGoals(personalGoal);\r\n            view.giveCommonGoals((String) data[6], (String) data[7]);\r\n            view.notifyGameHasStared();\r\n            if(playerName.equals(((List<String>) data[1]).get(0)))\r\n                view.pickTiles(3);\r\n            else\r\n                view.playerIsPlaying(((List<String>) data[1]).get(0));\r\n        } catch(ClassCastException ignored) {}\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    @SuppressWarnings({\"unchecked\", \"DuplicatedCode\", \"StatementWithEmptyBody\"})\r\n    public void newTurn(@NotNull Message msg) {\r\n        if(!msg.playerName().equals(playerName) ||\r\n                msg.messageID() != MessageID.NEW_TURN) return;\r\n        Object[] data = msg.contents();\r\n        try {\r\n            view.updateBoard((Tile[][]) data[0]);\r\n            if(!(boolean) data[1]) view.updateEndGameToken(false);\r\n            for(Object tile: ((Map<Tile, Integer>) data[3]).keySet()) {}\r\n            for(Object integer: ((Map<Tile, Integer>) data[3]).values()) {}\r\n            view.updateBag((Map<Tile, Integer>) data[3]);\r\n            for(Object integer: (Stack<Integer>) data[4]) {}\r\n            view.updateCommonGoal1TokenStack((Stack<Integer>) data[4]);\r\n            if(data[5] != null) {\r\n                for(Object integer: ((Map<Integer, String>) data[5]).keySet()) {}\r\n                for(Object string: ((Map<Integer, String>) data[5]).values()) {}\r\n                view.updateCommonGoal1GivenPlayers((Map<Integer, String>) data[5]);\r\n                for(int token: ((Map<Integer, String>) data[5]).keySet())\r\n                    view.assignCommonGoalPoints(((Map<Integer, String>) data[5]).get(token), token);\r\n            }\r\n            for(Object integer: (Stack<Integer>) data[6]) {}\r\n            view.updateCommonGoal2TokenStack((Stack<Integer>) data[6]);\r\n            if(data[7] != null) {\r\n                for(Object integer: ((Map<Integer, String>) data[7]).keySet()) {}\r\n                for(Object string: ((Map<Integer, String>) data[7]).values()) {}\r\n                view.updateCommonGoal2GivenPlayers((Map<Integer, String>) data[7]);\r\n                for(int token: ((Map<Integer, String>) data[7]).keySet())\r\n                    view.assignCommonGoalPoints(((Map<Integer, String>) data[7]).get(token), token);\r\n            }\r\n            view.updatePlayerShelves((Map<String, Tile[][]>) data[8]);\r\n            if(data[9] != null) view.updatePlayerPoints((Map<String, Integer>) data[9]);\r\n            if(data.length == 15) {\r\n                Object[] endGameStuff = {data[10], data[11], data[12], data[13], data[14]};\r\n                endGame(endGameStuff);\r\n            }\r\n            if(playerName.equals(data[10]))\r\n                view.pickTiles((int) data[11]);\r\n            else\r\n                view.playerIsPlaying((String) data[10]);\r\n        } catch (ClassCastException ignored) {}\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    @SuppressWarnings(\"unchecked\")\r\n    public void pickAccepted(@NotNull Message msg) {\r\n        if(!msg.playerName().equals(playerName) ||\r\n                msg.messageID() != MessageID.PICK_ACCEPTED ||\r\n                !(msg.content() instanceof List<?>)) return;\r\n        for(Object tile: (List<?>) msg.content())\r\n            if(!(tile instanceof Tile)) return;\r\n        view.chooseOrder((List<Tile>) msg.content());\r\n    }\r\n\r\n    /**\r\n     * If it is the last turn, end game actions are to be made.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @param data is the data from the last server message\r\n     */\r\n    @SuppressWarnings({\"unchecked\", \"StatementWithEmptyBody\"})\r\n    private void endGame(Object @NotNull [] data) {\r\n        try {\r\n            if(data[0] != null) {\r\n                for(Integer points: (List<Integer>) data[0]) {}\r\n                view.givePersonalGoals((List<Integer>) data[0]);\r\n            }\r\n        } catch(ClassCastException ignored) {}\r\n        try {\r\n            if(data[1] != null) {\r\n                for(String player: ((Map<String, Integer>) data[1]).keySet()) {}\r\n                for(Integer points: ((Map<String, Integer>) data[1]).values()) {}\r\n                view.assignPersonalGoalPoints((Map<String, Integer>) data[1]);\r\n            }\r\n        } catch(ClassCastException ignored) {}\r\n        try {\r\n            if(data[2] != null) {\r\n                for(String player: ((Map<String, Integer>) data[2]).keySet()) {}\r\n                for(Integer points: ((Map<String, Integer>) data[2]).values()) {}\r\n                view.assignAdjacentGoalPoints((Map<String, Integer>) data[2]);\r\n            }\r\n        } catch(ClassCastException ignored) {}\r\n        try {\r\n            if(data[3] != null && data[4] instanceof String) {\r\n                for(String player: ((Map<String, Integer>) data[3]).keySet()) {}\r\n                for(Integer points: ((Map<String, Integer>) data[3]).values()) {}\r\n                view.announceWinner((String) data[4], (Map<String, Integer>) data[3]);\r\n            }\r\n        } catch(ClassCastException ignored) {}\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/client/clientController/GameClientController.java b/src/main/java/it/polimi/ingsw/client/clientController/GameClientController.java
--- a/src/main/java/it/polimi/ingsw/client/clientController/GameClientController.java	(revision 9039822922184e9b3ec12a41c48f7dae0dfd9a26)
+++ b/src/main/java/it/polimi/ingsw/client/clientController/GameClientController.java	(date 1683628675266)
@@ -46,12 +46,12 @@
      * Used to pass method request answer to the controller from the view.
      * It contains switch cases based on event type.
      *
-     * @author Francesco Ostidich
      * @param evt is the event information
+     * @author Francesco Ostidich
      */
     @SuppressWarnings("unchecked")
     public void update(@NotNull Event evt) {
-        switch(evt.eventName()) {
+        switch (evt.eventName()) {
             case START -> view.choosePlayerName();
             case CHOOSE_PLAYER_NAME -> {
                 this.playerName = (String) evt.value();
@@ -59,10 +59,11 @@
             }
             case CHOOSE_IP_ADDRESS -> {
                 server = clientNetwork.connect((String) evt.value(), playerName, this);
+                if (server == null) return;
                 view.chooseNewOrJoin();
             }
             case CHOOSE_NEW_OR_JOIN -> {
-                if(evt.value().equals("new")) view.chooseNewGamePlayerNumber();
+                if (evt.value().equals("new")) view.chooseNewGamePlayerNumber();
                 else server.askForRooms(new Message(playerName, MessageID.ASK_FOR_ROOMS));
             }
             case CHOOSE_NEW_GAME_PLAYER_NUMBER -> {
@@ -70,20 +71,22 @@
                 view.chooseNewGameName();
             }
             case CHOOSE_NEW_GAME_NAME -> {
-                if(evt.value().equals("back")) view.chooseNewOrJoin();
+                if (evt.value().equals("back")) view.chooseNewOrJoin();
                 server.createNewRoom(new Message(playerName, MessageID.CREATE_NEW_ROOM, evt.value(), newRoomPlayerNumber));
             }
             case CHOOSE_GAME_ROOM -> {
-                if(evt.value().equals("refresh")) server.askForRooms(new Message(playerName, MessageID.ASK_FOR_ROOMS));
-                else if(evt.value().equals("back")) view.chooseNewOrJoin();
+                if (evt.value().equals("refresh")) server.askForRooms(new Message(playerName, MessageID.ASK_FOR_ROOMS));
+                else if (evt.value().equals("back")) view.chooseNewOrJoin();
                 else server.joinRoom(new Message(playerName, MessageID.JOIN_ROOM, evt.value()));
             }
-            case PICK_TILES -> server.pickTilesRequest(new Message(playerName, MessageID.PICK_TILES_REQUEST, evt.value()));
+            case PICK_TILES ->
+                    server.pickTilesRequest(new Message(playerName, MessageID.PICK_TILES_REQUEST, evt.value()));
             case CHOOSE_ORDER -> {
                 orderChosen = (List<Tile>) evt.value();
                 view.chooseColumn();
             }
-            case CHOOSE_COLUMN -> server.insertTilesRequest(new Message(playerName, MessageID.INSERT_TILE_REQUEST, orderChosen, evt.value()));
+            case CHOOSE_COLUMN ->
+                    server.insertTilesRequest(new Message(playerName, MessageID.INSERT_TILE_REQUEST, orderChosen, evt.value()));
         }
     }
 
@@ -117,13 +120,15 @@
     @Override
     @SuppressWarnings({"unchecked", "StatementWithEmptyBody"})
     public void showRooms(@NotNull Message msg) {
-        if(!msg.playerName().equals(playerName) ||
+        if (!msg.playerName().equals(playerName) ||
                 msg.messageID() != MessageID.SHOW_ROOMS ||
                 !(msg.content() instanceof List<?>)) return;
-        for(Object gameRoom: (List<?>) msg.content()) {}
-        try{
+        for (Object gameRoom : (List<?>) msg.content()) {
+        }
+        try {
             view.chooseGameRoom((List<GameRoom>) msg.content());
-        } catch (ClassCastException ignored) {}
+        } catch (ClassCastException ignored) {
+        }
     }
 
     /**
@@ -131,7 +136,7 @@
      */
     @Override
     public void showPersonalRoom(@NotNull Message msg) {
-        if(!msg.playerName().equals(playerName) ||
+        if (!msg.playerName().equals(playerName) ||
                 msg.messageID() != MessageID.SHOW_PERSONAL_ROOM ||
                 !(msg.content() instanceof GameRoom)) return;
         view.updateGameRoom((GameRoom) msg.content());
@@ -143,30 +148,37 @@
     @Override
     @SuppressWarnings({"unchecked", "DuplicatedCode", "StatementWithEmptyBody"})
     public void notifyGameHasStarted(@NotNull Message msg) {
-        if(!msg.playerName().equals(playerName) ||
+        if (!msg.playerName().equals(playerName) ||
                 msg.messageID() != MessageID.NOTIFY_GAME_HAS_STARTED) return;
         Object[] data = msg.contents();
         try {
-            for(Object string: ((Map<String, Integer>) data[0]).keySet()) {}
-            for(Object integer: ((Map<String, Integer>) data[0]).values()) {}
+            for (Object string : ((Map<String, Integer>) data[0]).keySet()) {
+            }
+            for (Object integer : ((Map<String, Integer>) data[0]).values()) {
+            }
             view.setGameParameters((Map<String, Integer>) data[0]);
-            for(Object string: (List<String>) data[1]) {}
+            for (Object string : (List<String>) data[1]) {
+            }
             view.turnCycleOrder((List<String>) data[1]);
-            for(Object tile: (Tile[][]) data[2]) {}
+            for (Object tile : (Tile[][]) data[2]) {
+            }
             view.updateBoard((Tile[][]) data[2]);
-            for(Object tile: ((Map<Tile, Integer>) data[3]).keySet()) {}
-            for(Object integer: ((Map<Tile, Integer>) data[3]).values()) {}
+            for (Object tile : ((Map<Tile, Integer>) data[3]).keySet()) {
+            }
+            for (Object integer : ((Map<Tile, Integer>) data[3]).values()) {
+            }
             view.updateBag((Map<Tile, Integer>) data[3]);
-            for(Object integer: (Stack<Integer>) data[4]) {}
+            for (Object integer : (Stack<Integer>) data[4]) {
+            }
             view.updateCommonGoal1TokenStack((Stack<Integer>) data[4]);
             view.updateCommonGoal2TokenStack((Stack<Integer>) data[4]);
             Map<String, Integer> playerPoints = new HashMap<>();
-            for(String player: (List<String>)data[1])
+            for (String player : (List<String>) data[1])
                 playerPoints.put(player, 0);
             view.updatePlayerPoints(playerPoints);
             Tile[][] shelf = new Tile[((Map<String, Integer>) data[0]).get("shelfColumnNumber")][((Map<String, Integer>) data[0]).get("shelfRowNumber")];
             Map<String, Tile[][]> playerShelves = new HashMap<>();
-            for(String player: (List<String>)data[1])
+            for (String player : (List<String>) data[1])
                 playerShelves.put(player, shelf);
             view.updatePlayerShelves(playerShelves);
             List<Integer> personalGoal = new LinkedList<>();
@@ -174,11 +186,12 @@
             view.givePersonalGoals(personalGoal);
             view.giveCommonGoals((String) data[6], (String) data[7]);
             view.notifyGameHasStared();
-            if(playerName.equals(((List<String>) data[1]).get(0)))
+            if (playerName.equals(((List<String>) data[1]).get(0)))
                 view.pickTiles(3);
             else
                 view.playerIsPlaying(((List<String>) data[1]).get(0));
-        } catch(ClassCastException ignored) {}
+        } catch (ClassCastException ignored) {
+        }
     }
 
     /**
@@ -187,44 +200,53 @@
     @Override
     @SuppressWarnings({"unchecked", "DuplicatedCode", "StatementWithEmptyBody"})
     public void newTurn(@NotNull Message msg) {
-        if(!msg.playerName().equals(playerName) ||
+        if (!msg.playerName().equals(playerName) ||
                 msg.messageID() != MessageID.NEW_TURN) return;
         Object[] data = msg.contents();
         try {
             view.updateBoard((Tile[][]) data[0]);
-            if(!(boolean) data[1]) view.updateEndGameToken(false);
-            for(Object tile: ((Map<Tile, Integer>) data[3]).keySet()) {}
-            for(Object integer: ((Map<Tile, Integer>) data[3]).values()) {}
+            if (!(boolean) data[1]) view.updateEndGameToken(false);
+            for (Object tile : ((Map<Tile, Integer>) data[3]).keySet()) {
+            }
+            for (Object integer : ((Map<Tile, Integer>) data[3]).values()) {
+            }
             view.updateBag((Map<Tile, Integer>) data[3]);
-            for(Object integer: (Stack<Integer>) data[4]) {}
+            for (Object integer : (Stack<Integer>) data[4]) {
+            }
             view.updateCommonGoal1TokenStack((Stack<Integer>) data[4]);
-            if(data[5] != null) {
-                for(Object integer: ((Map<Integer, String>) data[5]).keySet()) {}
-                for(Object string: ((Map<Integer, String>) data[5]).values()) {}
+            if (data[5] != null) {
+                for (Object integer : ((Map<Integer, String>) data[5]).keySet()) {
+                }
+                for (Object string : ((Map<Integer, String>) data[5]).values()) {
+                }
                 view.updateCommonGoal1GivenPlayers((Map<Integer, String>) data[5]);
-                for(int token: ((Map<Integer, String>) data[5]).keySet())
+                for (int token : ((Map<Integer, String>) data[5]).keySet())
                     view.assignCommonGoalPoints(((Map<Integer, String>) data[5]).get(token), token);
             }
-            for(Object integer: (Stack<Integer>) data[6]) {}
+            for (Object integer : (Stack<Integer>) data[6]) {
+            }
             view.updateCommonGoal2TokenStack((Stack<Integer>) data[6]);
-            if(data[7] != null) {
-                for(Object integer: ((Map<Integer, String>) data[7]).keySet()) {}
-                for(Object string: ((Map<Integer, String>) data[7]).values()) {}
+            if (data[7] != null) {
+                for (Object integer : ((Map<Integer, String>) data[7]).keySet()) {
+                }
+                for (Object string : ((Map<Integer, String>) data[7]).values()) {
+                }
                 view.updateCommonGoal2GivenPlayers((Map<Integer, String>) data[7]);
-                for(int token: ((Map<Integer, String>) data[7]).keySet())
+                for (int token : ((Map<Integer, String>) data[7]).keySet())
                     view.assignCommonGoalPoints(((Map<Integer, String>) data[7]).get(token), token);
             }
             view.updatePlayerShelves((Map<String, Tile[][]>) data[8]);
-            if(data[9] != null) view.updatePlayerPoints((Map<String, Integer>) data[9]);
-            if(data.length == 15) {
+            if (data[9] != null) view.updatePlayerPoints((Map<String, Integer>) data[9]);
+            if (data.length == 15) {
                 Object[] endGameStuff = {data[10], data[11], data[12], data[13], data[14]};
                 endGame(endGameStuff);
             }
-            if(playerName.equals(data[10]))
+            if (playerName.equals(data[10]))
                 view.pickTiles((int) data[11]);
             else
                 view.playerIsPlaying((String) data[10]);
-        } catch (ClassCastException ignored) {}
+        } catch (ClassCastException ignored) {
+        }
     }
 
     /**
@@ -233,49 +255,60 @@
     @Override
     @SuppressWarnings("unchecked")
     public void pickAccepted(@NotNull Message msg) {
-        if(!msg.playerName().equals(playerName) ||
+        if (!msg.playerName().equals(playerName) ||
                 msg.messageID() != MessageID.PICK_ACCEPTED ||
                 !(msg.content() instanceof List<?>)) return;
-        for(Object tile: (List<?>) msg.content())
-            if(!(tile instanceof Tile)) return;
+        for (Object tile : (List<?>) msg.content())
+            if (!(tile instanceof Tile)) return;
         view.chooseOrder((List<Tile>) msg.content());
     }
 
     /**
      * If it is the last turn, end game actions are to be made.
      *
-     * @author Francesco Ostidich
      * @param data is the data from the last server message
+     * @author Francesco Ostidich
      */
     @SuppressWarnings({"unchecked", "StatementWithEmptyBody"})
     private void endGame(Object @NotNull [] data) {
         try {
-            if(data[0] != null) {
-                for(Integer points: (List<Integer>) data[0]) {}
+            if (data[0] != null) {
+                for (Integer points : (List<Integer>) data[0]) {
+                }
                 view.givePersonalGoals((List<Integer>) data[0]);
             }
-        } catch(ClassCastException ignored) {}
+        } catch (ClassCastException ignored) {
+        }
         try {
-            if(data[1] != null) {
-                for(String player: ((Map<String, Integer>) data[1]).keySet()) {}
-                for(Integer points: ((Map<String, Integer>) data[1]).values()) {}
+            if (data[1] != null) {
+                for (String player : ((Map<String, Integer>) data[1]).keySet()) {
+                }
+                for (Integer points : ((Map<String, Integer>) data[1]).values()) {
+                }
                 view.assignPersonalGoalPoints((Map<String, Integer>) data[1]);
             }
-        } catch(ClassCastException ignored) {}
+        } catch (ClassCastException ignored) {
+        }
         try {
-            if(data[2] != null) {
-                for(String player: ((Map<String, Integer>) data[2]).keySet()) {}
-                for(Integer points: ((Map<String, Integer>) data[2]).values()) {}
+            if (data[2] != null) {
+                for (String player : ((Map<String, Integer>) data[2]).keySet()) {
+                }
+                for (Integer points : ((Map<String, Integer>) data[2]).values()) {
+                }
                 view.assignAdjacentGoalPoints((Map<String, Integer>) data[2]);
             }
-        } catch(ClassCastException ignored) {}
+        } catch (ClassCastException ignored) {
+        }
         try {
-            if(data[3] != null && data[4] instanceof String) {
-                for(String player: ((Map<String, Integer>) data[3]).keySet()) {}
-                for(Integer points: ((Map<String, Integer>) data[3]).values()) {}
+            if (data[3] != null && data[4] instanceof String) {
+                for (String player : ((Map<String, Integer>) data[3]).keySet()) {
+                }
+                for (Integer points : ((Map<String, Integer>) data[3]).values()) {
+                }
                 view.announceWinner((String) data[4], (Map<String, Integer>) data[3]);
             }
-        } catch(ClassCastException ignored) {}
+        } catch (ClassCastException ignored) {
+        }
     }
 
 }
Index: src/main/java/it/polimi/ingsw/server/model/AdjacentTilesGoal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.server.model;\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.JsonElement;\r\nimport com.google.gson.JsonParser;\r\nimport com.google.gson.reflect.TypeToken;\r\nimport it.polimi.ingsw.resources.exceptions.ConfigFileNotFoundException;\r\nimport it.polimi.ingsw.resources.Coordinates;\r\nimport it.polimi.ingsw.resources.Tile;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.util.*;\r\n\r\n/**\r\n * At the end of the game set it's needed to count how many groups and respective points are found in a player's shelf.\r\n * Groups' sizes and points are to be found in a map imported from json config file.\r\n *\r\n * @author Abdullah Nasr\r\n */\r\npublic class AdjacentTilesGoal {\r\n\r\n    private static final Map<Integer, Integer> groupPoints = getGroupPointsFromFile();\r\n\r\n    private static Tile[][] copy;\r\n\r\n    private static final Queue<Coordinates> currAdjTiles = new LinkedList<>();\r\n\r\n\r\n    /**\r\n     * It assigns points to the player based on the groups it has managed to build up.\r\n     *\r\n     * @param player is the player to give points to\r\n     * @author Abdullah Nasr\r\n     */\r\n    public static void assignPoints(@NotNull Player player) {\r\n        player.addPoints(calculatePoints(player.getShelf()));\r\n    }\r\n\r\n    /**\r\n     * count the number of tiles in the block in coordinate x,y\r\n     * @param x coordinate x\r\n     * @param y coordinate y\r\n     * @author Abdullah Nasr\r\n     */\r\n    @SuppressWarnings(\"DuplicatedCode\")\r\n    private static int countTilesBlock(int x, int y){\r\n        int count=0;\r\n        int xTemp;\r\n        int yTemp;\r\n\r\n        currAdjTiles.addAll(adjacentTile(x, y));\r\n        copy[x][y]=Tile.EMPTY;\r\n        count++;\r\n\r\n        while(currAdjTiles.size()>0) {\r\n\r\n            xTemp=currAdjTiles.peek().x();\r\n            yTemp=currAdjTiles.peek().y();\r\n            currAdjTiles.remove();\r\n            for(Coordinates e : adjacentTile(xTemp, yTemp)){\r\n                if(!currAdjTiles.stream().toList().contains(e))\r\n                    currAdjTiles.add(e);\r\n            }\r\n            copy[xTemp][yTemp]=Tile.EMPTY;\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * returns the points gained by the player with adjacent item tiles rules\r\n     * @param shelf player's shelf\r\n     * @return the total points gained with adjacent item tiles rules\r\n     * @author Abdullah Nasr\r\n     */\r\n    private static int calculatePoints(@NotNull Shelf shelf) {\r\n        int count;\r\n        int totPoints =0;\r\n        int maxTilesGroup = new ArrayList<>(groupPoints.keySet()).get(groupPoints.size()-1);\r\n\r\n        copy = shelf.getPositions().clone();\r\n\r\n        for (int i = 0; i < shelf.getRowNumber(); i++)\r\n            for (int j = 0; j < shelf.getColumnNumber(); j++)\r\n                if (copy[i][j] != Tile.EMPTY && copy[i][j] !=null) {\r\n                    count = countTilesBlock(i,j);\r\n\r\n                    if(count >= maxTilesGroup)\r\n                        totPoints+= groupPoints.get(maxTilesGroup);\r\n                    else if(groupPoints.containsKey(count))\r\n                        totPoints+= groupPoints.get(count);\r\n                }\r\n\r\n        return totPoints;\r\n    }\r\n\r\n    /**\r\n     * create a list of coordinates with the adjacent tiles of the tile in coordinate x,y\r\n     * @param x coordinate x\r\n     * @param y coordinate y\r\n     * @return a list of coordinates with the adjacent tiles of tile in coordinate x,y\r\n     * @author Abdullah Nasr\r\n     */\r\n    @SuppressWarnings(\"DuplicatedCode\")\r\n    private static @NotNull List<Coordinates> adjacentTile(int x, int y) {\r\n\r\n        List<Coordinates> adjTile = new ArrayList<>();\r\n\r\n        if (x <= 4)\r\n            if(copy[x + 1][y]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){\r\n                Coordinates coords = new Coordinates(x+1,y);\r\n                adjTile.add(coords);\r\n            }\r\n\r\n\r\n        if (x>=1)\r\n            if(copy[x - 1][y]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){\r\n                Coordinates coords = new Coordinates(x-1,y);\r\n                adjTile.add(coords);\r\n            }\r\n\r\n        if (y <= 3)\r\n            if(copy[x ][y+1]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){\r\n                Coordinates coords = new Coordinates(x,y+1);\r\n                adjTile.add(coords);\r\n            }\r\n\r\n        if (y >= 1)\r\n            if(copy[x ][y-1]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){\r\n                Coordinates coords = new Coordinates(x,y-1);\r\n                adjTile.add(coords);\r\n            }\r\n\r\n        return adjTile;\r\n    }\r\n\r\n    /**\r\n     * Generates a map with group points, retrieving data from json config file.\r\n     *\r\n     * @return map of groups' points retrieved from json config file\r\n     * @author Abdullah Nasr\r\n     */\r\n    private static @NotNull Map<Integer, Integer> getGroupPointsFromFile() {\r\n\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        Gson gson = new Gson();\r\n\r\n        File input = new File(\"src/main/java/it/polimi/ingsw/resources/configFiles/adjacentTilesGoalGroupPointsMap.json\");\r\n        try {\r\n            JsonElement pointsElement = JsonParser.parseReader(new FileReader(input));\r\n            map.putAll(gson.fromJson(pointsElement, new TypeToken<HashMap<Integer, Integer>>() {}.getType()));\r\n\r\n        } catch (FileNotFoundException e) {\r\n            throw new ConfigFileNotFoundException(\"personalGoalPointsMap not found\");\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Getter for adjacent goal group points.\r\n     *\r\n     * @author Abdullah Nasr\r\n     * @return groups points map\r\n     */\r\n    public static Map<Integer, Integer> getGroupPoints() {\r\n        return groupPoints;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/server/model/AdjacentTilesGoal.java b/src/main/java/it/polimi/ingsw/server/model/AdjacentTilesGoal.java
--- a/src/main/java/it/polimi/ingsw/server/model/AdjacentTilesGoal.java	(revision 9039822922184e9b3ec12a41c48f7dae0dfd9a26)
+++ b/src/main/java/it/polimi/ingsw/server/model/AdjacentTilesGoal.java	(date 1683628675412)
@@ -41,30 +41,31 @@
 
     /**
      * count the number of tiles in the block in coordinate x,y
+     *
      * @param x coordinate x
      * @param y coordinate y
      * @author Abdullah Nasr
      */
     @SuppressWarnings("DuplicatedCode")
-    private static int countTilesBlock(int x, int y){
-        int count=0;
+    private static int countTilesBlock(int x, int y) {
+        int count = 0;
         int xTemp;
         int yTemp;
 
         currAdjTiles.addAll(adjacentTile(x, y));
-        copy[x][y]=Tile.EMPTY;
+        copy[x][y] = Tile.EMPTY;
         count++;
 
-        while(currAdjTiles.size()>0) {
+        while (currAdjTiles.size() > 0) {
 
-            xTemp=currAdjTiles.peek().x();
-            yTemp=currAdjTiles.peek().y();
+            xTemp = currAdjTiles.peek().x();
+            yTemp = currAdjTiles.peek().y();
             currAdjTiles.remove();
-            for(Coordinates e : adjacentTile(xTemp, yTemp)){
-                if(!currAdjTiles.stream().toList().contains(e))
+            for (Coordinates e : adjacentTile(xTemp, yTemp)) {
+                if (!currAdjTiles.stream().toList().contains(e))
                     currAdjTiles.add(e);
             }
-            copy[xTemp][yTemp]=Tile.EMPTY;
+            copy[xTemp][yTemp] = Tile.EMPTY;
             count++;
         }
         return count;
@@ -72,26 +73,27 @@
 
     /**
      * returns the points gained by the player with adjacent item tiles rules
+     *
      * @param shelf player's shelf
      * @return the total points gained with adjacent item tiles rules
      * @author Abdullah Nasr
      */
     private static int calculatePoints(@NotNull Shelf shelf) {
         int count;
-        int totPoints =0;
-        int maxTilesGroup = new ArrayList<>(groupPoints.keySet()).get(groupPoints.size()-1);
+        int totPoints = 0;
+        int maxTilesGroup = new ArrayList<>(groupPoints.keySet()).get(groupPoints.size() - 1);
 
         copy = shelf.getPositions().clone();
 
         for (int i = 0; i < shelf.getRowNumber(); i++)
             for (int j = 0; j < shelf.getColumnNumber(); j++)
-                if (copy[i][j] != Tile.EMPTY && copy[i][j] !=null) {
-                    count = countTilesBlock(i,j);
+                if (copy[i][j] != Tile.EMPTY && copy[i][j] != null) {
+                    count = countTilesBlock(i, j);
 
-                    if(count >= maxTilesGroup)
-                        totPoints+= groupPoints.get(maxTilesGroup);
-                    else if(groupPoints.containsKey(count))
-                        totPoints+= groupPoints.get(count);
+                    if (count >= maxTilesGroup)
+                        totPoints += groupPoints.get(maxTilesGroup);
+                    else if (groupPoints.containsKey(count))
+                        totPoints += groupPoints.get(count);
                 }
 
         return totPoints;
@@ -99,6 +101,7 @@
 
     /**
      * create a list of coordinates with the adjacent tiles of the tile in coordinate x,y
+     *
      * @param x coordinate x
      * @param y coordinate y
      * @return a list of coordinates with the adjacent tiles of tile in coordinate x,y
@@ -110,27 +113,27 @@
         List<Coordinates> adjTile = new ArrayList<>();
 
         if (x <= 4)
-            if(copy[x + 1][y]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){
-                Coordinates coords = new Coordinates(x+1,y);
+            if (copy[x + 1][y] == copy[x][y] && copy[x][y] != null && copy[x][y] != Tile.EMPTY) {
+                Coordinates coords = new Coordinates(x + 1, y);
                 adjTile.add(coords);
             }
 
 
-        if (x>=1)
-            if(copy[x - 1][y]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){
-                Coordinates coords = new Coordinates(x-1,y);
+        if (x >= 1)
+            if (copy[x - 1][y] == copy[x][y] && copy[x][y] != null && copy[x][y] != Tile.EMPTY) {
+                Coordinates coords = new Coordinates(x - 1, y);
                 adjTile.add(coords);
             }
 
         if (y <= 3)
-            if(copy[x ][y+1]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){
-                Coordinates coords = new Coordinates(x,y+1);
+            if (copy[x][y + 1] == copy[x][y] && copy[x][y] != null && copy[x][y] != Tile.EMPTY) {
+                Coordinates coords = new Coordinates(x, y + 1);
                 adjTile.add(coords);
             }
 
         if (y >= 1)
-            if(copy[x ][y-1]==copy[x][y] && copy[x][y]!=null &&copy[x][y]!=Tile.EMPTY){
-                Coordinates coords = new Coordinates(x,y-1);
+            if (copy[x][y - 1] == copy[x][y] && copy[x][y] != null && copy[x][y] != Tile.EMPTY) {
+                Coordinates coords = new Coordinates(x, y - 1);
                 adjTile.add(coords);
             }
 
@@ -151,7 +154,8 @@
         File input = new File("src/main/java/it/polimi/ingsw/resources/configFiles/adjacentTilesGoalGroupPointsMap.json");
         try {
             JsonElement pointsElement = JsonParser.parseReader(new FileReader(input));
-            map.putAll(gson.fromJson(pointsElement, new TypeToken<HashMap<Integer, Integer>>() {}.getType()));
+            map.putAll(gson.fromJson(pointsElement, new TypeToken<HashMap<Integer, Integer>>() {
+            }.getType()));
 
         } catch (FileNotFoundException e) {
             throw new ConfigFileNotFoundException("personalGoalPointsMap not found");
@@ -162,8 +166,8 @@
     /**
      * Getter for adjacent goal group points.
      *
-     * @author Abdullah Nasr
      * @return groups points map
+     * @author Abdullah Nasr
      */
     public static Map<Integer, Integer> getGroupPoints() {
         return groupPoints;
Index: src/main/java/it/polimi/ingsw/client/view/GameClientView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.client.view;\r\n\r\nimport it.polimi.ingsw.client.clientController.GameClientController;\r\nimport it.polimi.ingsw.resources.GameRoom;\r\nimport it.polimi.ingsw.resources.Tile;\r\nimport it.polimi.ingsw.resources.interfaces.ClientController;\r\nimport it.polimi.ingsw.resources.interfaces.ClientView;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * Controller is to call action on the game view, which can be implemented with a GUI or a CLI.\r\n * This class contains all the attributes the UI is to print or that should be able to show when requested.\r\n * All the abstract actions requires something to be printed and something to be scanned, and returned after\r\n * being checked if legal.\r\n *\r\n * @author Francesco Ostidich\r\n */\r\npublic abstract class GameClientView implements ClientView {\r\n\r\n    private final ClientController clientController;\r\n\r\n    private static final int TIMEOUT = 20;\r\n\r\n    private final Map<String, Integer> gameParameters;\r\n\r\n    private final List<String> names;\r\n\r\n    private Tile[][] board;\r\n\r\n    private boolean endGameToken;\r\n\r\n    private Map<Tile, Integer> bag;\r\n\r\n    private String commonGoal1;\r\n\r\n    private String commonGoal2;\r\n\r\n    private Stack<Integer> commonGoal1TokenStack;\r\n\r\n    private Stack<Integer> commonGoal2TokenStack;\r\n\r\n    private final Map<Integer, String> commonGoal1GivenPlayers;\r\n\r\n    private final Map<Integer, String> commonGoal2GivenPlayers;\r\n\r\n    private final Map<String, Tile[][]> playerShelves;\r\n\r\n    private final Map<String, Integer> playerPoints;\r\n\r\n    private List<Integer> playerPersonalGoals;\r\n\r\n    private String IPAddress;\r\n\r\n    private List<GameRoom> gameRooms;\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @author Francesco Ostidich\r\n     */\r\n    public GameClientView(String network) {\r\n        gameParameters = new HashMap<>();\r\n        names = new LinkedList<>();\r\n        endGameToken = true;\r\n        bag = new HashMap<>();\r\n        commonGoal1GivenPlayers = new HashMap<>();\r\n        commonGoal2GivenPlayers = new HashMap<>();\r\n        playerShelves = new HashMap<>();\r\n        playerPoints = new HashMap<>();\r\n        playerPersonalGoals = new LinkedList<>();\r\n        gameRooms = new ArrayList<>();\r\n        clientController = new GameClientController(this, network);\r\n    }\r\n\r\n    /**\r\n     * Getter for game client controller.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return game client controller\r\n     */\r\n    public ClientController getClientController() {\r\n        return clientController;\r\n    }\r\n\r\n    /**\r\n     * Getter for names.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return names list\r\n     */\r\n    public List<String> getNames() {\r\n        return names;\r\n    }\r\n\r\n    /**\r\n     * Getter for game parameters.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return game parameters map\r\n     */\r\n    public Map<String, Integer> getGameParameters() {\r\n        return gameParameters;\r\n    }\r\n\r\n    /**\r\n     * Getter for bag.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return bag map\r\n     */\r\n    public Map<Tile, Integer> getBag() {\r\n        return bag;\r\n    }\r\n\r\n    /**\r\n     * Getter for common goal 1 give players.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return given players map\r\n     */\r\n    public Map<Integer, String> getCommonGoal1GivenPlayers() {\r\n        return commonGoal1GivenPlayers;\r\n    }\r\n\r\n    /**\r\n     * Getter for common goal 1 token stack.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return tokens stack\r\n     */\r\n    public Stack<Integer> getCommonGoal1TokenStack() {\r\n        return commonGoal1TokenStack;\r\n    }\r\n\r\n    /**\r\n     * Getter for players' shelves.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return shelves list\r\n     */\r\n    public Map<String, Tile[][]> getPlayerShelves() {\r\n        return playerShelves;\r\n    }\r\n\r\n    /**\r\n     * Getter for common goal 2 token stack.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return tokens stack\r\n     */\r\n    public Stack<Integer> getCommonGoal2TokenStack() {\r\n        return commonGoal2TokenStack;\r\n    }\r\n\r\n    /**\r\n     * Getter for common goal 1.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return common goal 1 ID string\r\n     */\r\n    public String getCommonGoal1() {\r\n        return commonGoal1;\r\n    }\r\n\r\n    /**\r\n     * Getter for common goal 2.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return common goal 2 ID string\r\n     */\r\n    public String getCommonGoal2() {\r\n        return commonGoal2;\r\n    }\r\n\r\n    /**\r\n     * Getter for common goal 2 given players.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return given players map\r\n     */\r\n    public Map<Integer, String> getCommonGoal2GivenPlayers() {\r\n        return commonGoal2GivenPlayers;\r\n    }\r\n\r\n    /**\r\n     * Getter for board.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return board matrix\r\n     */\r\n    public Tile[][] getBoard() {\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * Getter for players' personal goals.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return personal goals IDs list\r\n     */\r\n    public List<Integer> getPlayerPersonalGoals() {\r\n        return playerPersonalGoals;\r\n    }\r\n\r\n    /**\r\n     * Getter for players' points.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return points number\r\n     */\r\n    public Map<String, Integer> getPlayerPoints() {\r\n        return playerPoints;\r\n    }\r\n\r\n    /**\r\n     * Getter for server's IP address.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return IP address string\r\n     */\r\n    public String getIPAddress() {\r\n        return IPAddress;\r\n    }\r\n\r\n    /**\r\n     * Getter for game rooms.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return game rooms list\r\n     */\r\n    public List<GameRoom> getGameRooms() {\r\n        return gameRooms;\r\n    }\r\n\r\n    /**\r\n     * Getter for end game token.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return end game token boolean\r\n     */\r\n    public boolean getEndGameToken() {\r\n        return endGameToken;\r\n    }\r\n\r\n    /**\r\n     * Getter for timeout.\r\n     *\r\n     * @author Francesco Ostidich\r\n     * @return time out seconds\r\n     */\r\n    public static int getTimeout() {\r\n        return TIMEOUT;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void setGameParameters(Map<String, Integer> gameParameters) {\r\n        this.gameParameters.putAll(gameParameters);\r\n        board = new Tile[this.gameParameters.get(\"boardRowLength\")][this.gameParameters.get(\"boardColumnLength\")];\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void turnCycleOrder(List<String> names) {\r\n        this.names.addAll(names);\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateBoard(Tile[][] board) {\r\n        this.board = board;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateEndGameToken(boolean present) {\r\n        endGameToken = present;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateBag(Map<Tile, Integer> tilesLeft) {\r\n        this.bag = tilesLeft;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateGameRooms(List<GameRoom> gameRooms) {\r\n        this.gameRooms = gameRooms;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateGameRoom(GameRoom gameRoom) {\r\n        for(int i = 0; i < gameRooms.size(); i++) {\r\n            if(gameRooms.get(i).gameRoomName().equals(gameRoom.gameRoomName())) {\r\n                gameRooms.set(i, gameRoom);\r\n                return;\r\n            }\r\n        }\r\n        gameRooms.add(gameRoom);\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateCommonGoal1TokenStack(Stack<Integer> tokenStack) {\r\n        this.commonGoal1TokenStack = tokenStack;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateCommonGoal1GivenPlayers(@NotNull Map<Integer, String> givenPlayer) {\r\n        for(int token: givenPlayer.keySet()){\r\n            this.commonGoal1GivenPlayers.replace(token, givenPlayer.get(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateCommonGoal2TokenStack(Stack<Integer> tokenStack) {\r\n        this.commonGoal1TokenStack = tokenStack;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updateCommonGoal2GivenPlayers(@NotNull Map<Integer, String> givenPlayer) {\r\n        for(int token: givenPlayer.keySet()){\r\n            this.commonGoal2GivenPlayers.replace(token, givenPlayer.get(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updatePlayerShelves(@NotNull Map<String, Tile[][]> shelves) {\r\n        for(String player: shelves.keySet()) {\r\n            playerShelves.replace(player, shelves.get(player));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void updatePlayerPoints(@NotNull Map<String, Integer> points) {\r\n        for(String player: points.keySet()) {\r\n            playerPoints.replace(player, points.get(player));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void givePersonalGoals(List<Integer> personalGoals) {\r\n        playerPersonalGoals = personalGoals;\r\n    }\r\n\r\n    /**\r\n     * @author Francesco Ostidich\r\n     */\r\n    @Override\r\n    public void giveCommonGoals(String commonGoal1, String commonGoal2) {\r\n        this.commonGoal1 = commonGoal1;\r\n        this.commonGoal2 = commonGoal2;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/client/view/GameClientView.java b/src/main/java/it/polimi/ingsw/client/view/GameClientView.java
--- a/src/main/java/it/polimi/ingsw/client/view/GameClientView.java	(revision 9039822922184e9b3ec12a41c48f7dae0dfd9a26)
+++ b/src/main/java/it/polimi/ingsw/client/view/GameClientView.java	(date 1683628675304)
@@ -77,8 +77,8 @@
     /**
      * Getter for game client controller.
      *
-     * @author Francesco Ostidich
      * @return game client controller
+     * @author Francesco Ostidich
      */
     public ClientController getClientController() {
         return clientController;
@@ -87,8 +87,8 @@
     /**
      * Getter for names.
      *
+     * @return names list
      * @author Francesco Ostidich
-     * @return names list
      */
     public List<String> getNames() {
         return names;
@@ -97,8 +97,8 @@
     /**
      * Getter for game parameters.
      *
+     * @return game parameters map
      * @author Francesco Ostidich
-     * @return game parameters map
      */
     public Map<String, Integer> getGameParameters() {
         return gameParameters;
@@ -107,8 +107,8 @@
     /**
      * Getter for bag.
      *
-     * @author Francesco Ostidich
      * @return bag map
+     * @author Francesco Ostidich
      */
     public Map<Tile, Integer> getBag() {
         return bag;
@@ -117,8 +117,8 @@
     /**
      * Getter for common goal 1 give players.
      *
-     * @author Francesco Ostidich
      * @return given players map
+     * @author Francesco Ostidich
      */
     public Map<Integer, String> getCommonGoal1GivenPlayers() {
         return commonGoal1GivenPlayers;
@@ -127,8 +127,8 @@
     /**
      * Getter for common goal 1 token stack.
      *
+     * @return tokens stack
      * @author Francesco Ostidich
-     * @return tokens stack
      */
     public Stack<Integer> getCommonGoal1TokenStack() {
         return commonGoal1TokenStack;
@@ -137,8 +137,8 @@
     /**
      * Getter for players' shelves.
      *
-     * @author Francesco Ostidich
      * @return shelves list
+     * @author Francesco Ostidich
      */
     public Map<String, Tile[][]> getPlayerShelves() {
         return playerShelves;
@@ -147,8 +147,8 @@
     /**
      * Getter for common goal 2 token stack.
      *
-     * @author Francesco Ostidich
      * @return tokens stack
+     * @author Francesco Ostidich
      */
     public Stack<Integer> getCommonGoal2TokenStack() {
         return commonGoal2TokenStack;
@@ -157,8 +157,8 @@
     /**
      * Getter for common goal 1.
      *
-     * @author Francesco Ostidich
      * @return common goal 1 ID string
+     * @author Francesco Ostidich
      */
     public String getCommonGoal1() {
         return commonGoal1;
@@ -167,8 +167,8 @@
     /**
      * Getter for common goal 2.
      *
-     * @author Francesco Ostidich
      * @return common goal 2 ID string
+     * @author Francesco Ostidich
      */
     public String getCommonGoal2() {
         return commonGoal2;
@@ -177,8 +177,8 @@
     /**
      * Getter for common goal 2 given players.
      *
+     * @return given players map
      * @author Francesco Ostidich
-     * @return given players map
      */
     public Map<Integer, String> getCommonGoal2GivenPlayers() {
         return commonGoal2GivenPlayers;
@@ -187,8 +187,8 @@
     /**
      * Getter for board.
      *
+     * @return board matrix
      * @author Francesco Ostidich
-     * @return board matrix
      */
     public Tile[][] getBoard() {
         return board;
@@ -197,8 +197,8 @@
     /**
      * Getter for players' personal goals.
      *
-     * @author Francesco Ostidich
      * @return personal goals IDs list
+     * @author Francesco Ostidich
      */
     public List<Integer> getPlayerPersonalGoals() {
         return playerPersonalGoals;
@@ -207,8 +207,8 @@
     /**
      * Getter for players' points.
      *
-     * @author Francesco Ostidich
      * @return points number
+     * @author Francesco Ostidich
      */
     public Map<String, Integer> getPlayerPoints() {
         return playerPoints;
@@ -217,8 +217,8 @@
     /**
      * Getter for server's IP address.
      *
+     * @return IP address string
      * @author Francesco Ostidich
-     * @return IP address string
      */
     public String getIPAddress() {
         return IPAddress;
@@ -227,8 +227,8 @@
     /**
      * Getter for game rooms.
      *
-     * @author Francesco Ostidich
      * @return game rooms list
+     * @author Francesco Ostidich
      */
     public List<GameRoom> getGameRooms() {
         return gameRooms;
@@ -237,8 +237,8 @@
     /**
      * Getter for end game token.
      *
-     * @author Francesco Ostidich
      * @return end game token boolean
+     * @author Francesco Ostidich
      */
     public boolean getEndGameToken() {
         return endGameToken;
@@ -247,8 +247,8 @@
     /**
      * Getter for timeout.
      *
-     * @author Francesco Ostidich
      * @return time out seconds
+     * @author Francesco Ostidich
      */
     public static int getTimeout() {
         return TIMEOUT;
@@ -308,8 +308,8 @@
      */
     @Override
     public void updateGameRoom(GameRoom gameRoom) {
-        for(int i = 0; i < gameRooms.size(); i++) {
-            if(gameRooms.get(i).gameRoomName().equals(gameRoom.gameRoomName())) {
+        for (int i = 0; i < gameRooms.size(); i++) {
+            if (gameRooms.get(i).gameRoomName().equals(gameRoom.gameRoomName())) {
                 gameRooms.set(i, gameRoom);
                 return;
             }
@@ -330,7 +330,7 @@
      */
     @Override
     public void updateCommonGoal1GivenPlayers(@NotNull Map<Integer, String> givenPlayer) {
-        for(int token: givenPlayer.keySet()){
+        for (int token : givenPlayer.keySet()) {
             this.commonGoal1GivenPlayers.replace(token, givenPlayer.get(token));
         }
     }
@@ -348,7 +348,7 @@
      */
     @Override
     public void updateCommonGoal2GivenPlayers(@NotNull Map<Integer, String> givenPlayer) {
-        for(int token: givenPlayer.keySet()){
+        for (int token : givenPlayer.keySet()) {
             this.commonGoal2GivenPlayers.replace(token, givenPlayer.get(token));
         }
     }
@@ -358,7 +358,7 @@
      */
     @Override
     public void updatePlayerShelves(@NotNull Map<String, Tile[][]> shelves) {
-        for(String player: shelves.keySet()) {
+        for (String player : shelves.keySet()) {
             playerShelves.replace(player, shelves.get(player));
         }
     }
@@ -368,7 +368,7 @@
      */
     @Override
     public void updatePlayerPoints(@NotNull Map<String, Integer> points) {
-        for(String player: points.keySet()) {
+        for (String player : points.keySet()) {
             playerPoints.replace(player, points.get(player));
         }
     }
Index: src/main/java/it/polimi/ingsw/ClientApp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw;\r\n\r\nimport it.polimi.ingsw.client.view.CLI;\r\nimport it.polimi.ingsw.client.view.GUI;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class ClientApp {\r\n\r\n    public static void main(String @NotNull [] args) {\r\n        if(args.length == 0) {\r\n            args = new String[2];\r\n            args[0] = null;\r\n            args[1] = null;\r\n        }\r\n        else if(args.length == 1) {\r\n            String old = args[0];\r\n            args = new String[2];\r\n            args[0] = old;\r\n            args[1] = null;\r\n        }\r\n        if(Objects.equals(args[0], \"GUI\")) new GUI(args[1]);\r\n        else new CLI(args[1]);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/ClientApp.java b/src/main/java/it/polimi/ingsw/ClientApp.java
--- a/src/main/java/it/polimi/ingsw/ClientApp.java	(revision 9039822922184e9b3ec12a41c48f7dae0dfd9a26)
+++ b/src/main/java/it/polimi/ingsw/ClientApp.java	(date 1683628458856)
@@ -9,18 +9,17 @@
 public class ClientApp {
 
     public static void main(String @NotNull [] args) {
-        if(args.length == 0) {
+        if (args.length == 0) {
             args = new String[2];
             args[0] = null;
             args[1] = null;
-        }
-        else if(args.length == 1) {
+        } else if (args.length == 1) {
             String old = args[0];
             args = new String[2];
             args[0] = old;
             args[1] = null;
         }
-        if(Objects.equals(args[0], "GUI")) new GUI(args[1]);
+        if (Objects.equals(args[0], "GUI")) new GUI(args[1]);
         else new CLI(args[1]);
     }
 
Index: src/main/java/it/polimi/ingsw/client/clientNetwork/GameClientNetwork.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.client.clientNetwork;\r\n\r\nimport it.polimi.ingsw.resources.interfaces.ClientController;\r\nimport it.polimi.ingsw.resources.interfaces.ClientNetwork;\r\nimport it.polimi.ingsw.resources.interfaces.ServerController;\r\nimport it.polimi.ingsw.server.serverController.RoomServices;\r\n\r\n/**\r\n * Asks for connection to the server, and wants the ServerController interface to call methods on it.\r\n * When \"connect\" method is called, the connection must be built.\r\n * Every action done on the ServerController interface must be forwarded to the server either as RMI or Socket calling\r\n * the method directly in the server on the controller.\r\n */\r\npublic class GameClientNetwork implements ClientNetwork {\r\n\r\n    private final String connectionType;\r\n\r\n    private ClientController controller;\r\n\r\n    private String serverIP;\r\n\r\n    private String playerName;\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @param connectionType is the type of connection\r\n     * @author Francesco Ostidich\r\n     */\r\n    public GameClientNetwork(String connectionType) {\r\n        this.connectionType = connectionType;\r\n    }\r\n\r\n    @Override\r\n    public ServerController connect(String serverIP, String playerName, ClientController controller) {\r\n        this.serverIP = serverIP;\r\n        this.playerName = playerName;\r\n        this.controller = controller;\r\n        //to tweak:\r\n        ServerController serverController = new RoomServices();\r\n        if(serverController.onlinePlayers().contains(playerName)) controller.restart();\r\n        return null;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/client/clientNetwork/GameClientNetwork.java b/src/main/java/it/polimi/ingsw/client/clientNetwork/GameClientNetwork.java
--- a/src/main/java/it/polimi/ingsw/client/clientNetwork/GameClientNetwork.java	(revision 9039822922184e9b3ec12a41c48f7dae0dfd9a26)
+++ b/src/main/java/it/polimi/ingsw/client/clientNetwork/GameClientNetwork.java	(date 1683043394653)
@@ -38,8 +38,11 @@
         this.controller = controller;
         //to tweak:
         ServerController serverController = new RoomServices();
-        if(serverController.onlinePlayers().contains(playerName)) controller.restart();
-        return null;
+        if(serverController.onlinePlayers().contains(playerName)) {
+            controller.restart();
+            return null;
+        }
+        return serverController;
     }
 
 }
Index: src/main/java/it/polimi/ingsw/server/model/Board.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.server.model;\r\n\r\nimport com.google.gson.JsonArray;\r\nimport com.google.gson.JsonElement;\r\nimport com.google.gson.JsonObject;\r\nimport com.google.gson.JsonParser;\r\nimport it.polimi.ingsw.resources.exceptions.ConfigFileNotFoundException;\r\nimport it.polimi.ingsw.resources.exceptions.ConfigFileNotReadableException;\r\nimport it.polimi.ingsw.resources.Coordinates;\r\nimport it.polimi.ingsw.resources.Tile;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.util.*;\r\n\r\n/**\r\n * //TODO java doc is to be written\r\n * @author Edoardo Margarini\r\n */\r\npublic class Board {\r\n\r\n    private static final int ROW_LENGTH = 9;\r\n\r\n    private static final int COLUMN_LENGTH = 9;\r\n\r\n    private final Tile[][] spaces;\r\n\r\n    private final Bag bag = new Bag();\r\n\r\n    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\r\n    private Optional<EndGameToken> endGameToken;\r\n\r\n    /**\r\n     * Class constructor\r\n     * @author Edoardo Margarini\r\n     * @param num is players number\r\n     */\r\n    public Board(int num) {\r\n        spaces = new Tile[ROW_LENGTH][COLUMN_LENGTH];\r\n        endGameToken = Optional.of(new EndGameToken());\r\n\r\n        File input = new File(\"src/main/java/it/polimi/ingsw/resources/configFiles/boardSpacesMatrix.json\");\r\n        try {\r\n            JsonElement spacesElement = JsonParser.parseReader(new FileReader(input));\r\n            JsonObject spacesObject = spacesElement.getAsJsonObject();\r\n\r\n            JsonArray jsonSpaces = spacesObject.get(String.valueOf(num)).getAsJsonArray();\r\n            for(int i = 0; i < ROW_LENGTH; i++)\r\n                for(int j = 0; j < COLUMN_LENGTH; j++) {\r\n                    if(jsonSpaces.get(ROW_LENGTH *j + i).getAsInt() == 0) //22 = 9*2 + 4\r\n                        spaces[i][j] = null;\r\n                    else if(jsonSpaces.get(ROW_LENGTH *j + i).getAsInt() == 1)\r\n                        spaces[i][j] = Tile.EMPTY;\r\n                    else throw new ConfigFileNotReadableException(\"cannot read values else than 1 or 0\");\r\n                }\r\n        } catch (FileNotFoundException e) {\r\n            throw new ConfigFileNotFoundException(\"personalGoalPointsMap not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     */\r\n    protected void setEndGameToken(@SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\") Optional<EndGameToken> endGameToken) {\r\n        this.endGameToken = endGameToken;\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     * @return\r\n     */\r\n    protected Tile[][] getSpaces() {\r\n        return spaces;\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     */\r\n    protected void setSpace(@NotNull Coordinates coords, Tile tile){\r\n        spaces[coords.x()][coords.y()]=tile;\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     * @return\r\n     */\r\n    protected Bag getBag(){\r\n        return bag;\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     * @return\r\n     */\r\n    protected Optional<EndGameToken> getEndGameToken() {\r\n        return endGameToken;\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     */\r\n    protected void refill() {\r\n        //puts back the ones left on the board\r\n        emptyBoardInBag();\r\n\r\n        for (int i = 0; i < ROW_LENGTH; i++)\r\n            for (int j = 0; j < COLUMN_LENGTH; j++) {\r\n                if (spaces[i][j]== Tile.EMPTY) {\r\n                    Tile t=bag.draw();\r\n                    spaces[i][j] = t;\r\n                }\r\n            }\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     * @param selection\r\n     * @return\r\n     */\r\n    protected List<Tile> selectTiles(List<Coordinates> selection) {\r\n\r\n        List<Tile> list = new LinkedList<>();\r\n\r\n        if(checkSelection(selection)) {\r\n            for(Coordinates e : selection)\r\n                list.add(spaces[e.x()][e.y()]);\r\n\r\n            emptyTiles(selection);\r\n\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * A series of checks that allow to know if a move is allowed\r\n     * @author Edoardo Margarini\r\n     * @param selection is a list of coords of the board\r\n     * @return true if every check has positive feedback, false if one check has negative feedback\r\n     * */\r\n    protected boolean checkSelection(@NotNull List<Coordinates> selection) {\r\n        //checks the player has chosen max 3 tiles\r\n        if(selection.size()>3)\r\n            return false;\r\n\r\n        //checks the player has chosen available tiles (!=null !=Tile.EMPTY)\r\n        for(Coordinates e : selection) {\r\n            if(spaces[e.x()][e.y()]==null || spaces[e.x()][e.y()]==Tile.EMPTY)\r\n                return false;\r\n        }\r\n\r\n        //checks the player has chosen tiles that has a free adjacent\r\n        for(Coordinates e : selection) {\r\n            if(!adjacentTile(e).contains(null) && !adjacentTile(e).contains(Tile.EMPTY))\r\n                return false;\r\n        }\r\n\r\n        //checks the player has chosen 1 single tile, in this case all the tests made are sufficient\r\n        if(selection.size()==1)\r\n            return true;\r\n\r\n        //checks the player has chosen tiles in column or in row\r\n        List<Integer> listX=new ArrayList<>();\r\n        List<Integer> listY=new ArrayList<>();\r\n        for(Coordinates e : selection){\r\n            listX.add(e.x());\r\n            listY.add(e.y());\r\n        }\r\n        if(!listX.stream().allMatch(s -> s.equals(listX.get(0))) && !listY.stream().allMatch(s -> s.equals(listY.get(0))))\r\n            return false;\r\n\r\n\r\n        List<Integer> list;\r\n\r\n        if(Objects.equals(listX.get(0), listX.get(1)))\r\n            list = listY;\r\n        else\r\n            list = listX;\r\n\r\n        Collections.sort(list);\r\n\r\n        for(int i=0;i<list.size();i++){\r\n            if(list.get(i)!=list.get(0)+i)\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Deletes tiles from board, they are ready to be placed on a shelf\r\n     * @author Edoardo Margarini\r\n     * @param selection is a list of coords of the board\r\n     */\r\n    private void emptyTiles(@NotNull List<Coordinates> selection) {\r\n        selection.forEach((e)->spaces[e.x()][e.y()]=Tile.EMPTY);\r\n    }\r\n\r\n    /**\r\n     * Checks if the board is refillable\r\n     * @author Edoardo Margarini\r\n     * @return true or false\r\n     */\r\n    protected boolean checkToRefill() {\r\n\r\n        for(int i = 0; i < ROW_LENGTH; i++)\r\n            for(int j = 0; j < COLUMN_LENGTH; j++) {\r\n                if(!isCompletelyFree(new Coordinates(i, j)) && spaces[i][j]!=null && spaces[i][j]!=Tile.EMPTY)\r\n                    return false;\r\n            }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks if a tile has no other adjacent tiles\r\n     * @author Edoardo Margarini\r\n     * @param coords of a space in the board\r\n     * @return true or false\r\n     */\r\n    private boolean isCompletelyFree(Coordinates coords) {\r\n        return adjacentTile(coords).contains(Tile.EMPTY) ||\r\n                adjacentTile(coords).contains(null);\r\n    }\r\n\r\n    /**\r\n     * Adjacent tile\r\n     * @author Edoardo Margarini\r\n     * @param coords of a space in the board\r\n     * @return a list of adjacent Tile\r\n     */\r\n    private @NotNull List<Tile> adjacentTile(@NotNull Coordinates coords) {\r\n\r\n        List<Tile> adjTile = new LinkedList<>();\r\n\r\n        if(coords.x()> ROW_LENGTH)\r\n            adjTile.add(null);\r\n        else\r\n            adjTile.add(spaces[coords.x()+1][coords.y()]);\r\n\r\n        if(coords.x()<1)\r\n            adjTile.add(null);\r\n        else\r\n            adjTile.add(spaces[coords.x()-1][coords.y()]);\r\n\r\n        if(coords.y()> COLUMN_LENGTH)\r\n            adjTile.add(null);\r\n        else\r\n            adjTile.add(spaces[coords.x()][coords.y()+1]);\r\n\r\n        if(coords.y()<1)\r\n            adjTile.add(null);\r\n        else\r\n            adjTile.add(spaces[coords.x()][coords.y()-1]);\r\n\r\n        return adjTile;\r\n    }\r\n\r\n    /**\r\n     * //TODO java doc is to be written\r\n     * @author Edoardo Margarini\r\n     * @param coordinates\r\n     * @return\r\n     */\r\n    protected Tile getTileInBoard(@NotNull Coordinates coordinates) {\r\n        return spaces[coordinates.x()][coordinates.y()];\r\n    }\r\n\r\n    /**\r\n     * Puts all the tiles of the board in the bag\r\n     * @author Edoardo Margarini\r\n     */\r\n    private void emptyBoardInBag() {\r\n        for (int i = 0; i < ROW_LENGTH; i++)\r\n            for (int j = 0; j < COLUMN_LENGTH; j++) {\r\n                if (spaces[i][j] != null && spaces[i][j] != Tile.EMPTY) {\r\n                    bag.addTile(spaces[i][j]);\r\n                    spaces[i][j] = Tile.EMPTY;\r\n                }\r\n            }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/ingsw/server/model/Board.java b/src/main/java/it/polimi/ingsw/server/model/Board.java
--- a/src/main/java/it/polimi/ingsw/server/model/Board.java	(revision 9039822922184e9b3ec12a41c48f7dae0dfd9a26)
+++ b/src/main/java/it/polimi/ingsw/server/model/Board.java	(date 1683628675332)
@@ -17,6 +17,7 @@
 
 /**
  * //TODO java doc is to be written
+ *
  * @author Edoardo Margarini
  */
 public class Board {
@@ -34,8 +35,9 @@
 
     /**
      * Class constructor
-     * @author Edoardo Margarini
+     *
      * @param num is players number
+     * @author Edoardo Margarini
      */
     public Board(int num) {
         spaces = new Tile[ROW_LENGTH][COLUMN_LENGTH];
@@ -47,11 +49,11 @@
             JsonObject spacesObject = spacesElement.getAsJsonObject();
 
             JsonArray jsonSpaces = spacesObject.get(String.valueOf(num)).getAsJsonArray();
-            for(int i = 0; i < ROW_LENGTH; i++)
-                for(int j = 0; j < COLUMN_LENGTH; j++) {
-                    if(jsonSpaces.get(ROW_LENGTH *j + i).getAsInt() == 0) //22 = 9*2 + 4
+            for (int i = 0; i < ROW_LENGTH; i++)
+                for (int j = 0; j < COLUMN_LENGTH; j++) {
+                    if (jsonSpaces.get(ROW_LENGTH * j + i).getAsInt() == 0) //22 = 9*2 + 4
                         spaces[i][j] = null;
-                    else if(jsonSpaces.get(ROW_LENGTH *j + i).getAsInt() == 1)
+                    else if (jsonSpaces.get(ROW_LENGTH * j + i).getAsInt() == 1)
                         spaces[i][j] = Tile.EMPTY;
                     else throw new ConfigFileNotReadableException("cannot read values else than 1 or 0");
                 }
@@ -62,6 +64,7 @@
 
     /**
      * //TODO java doc is to be written
+     *
      * @author Edoardo Margarini
      */
     protected void setEndGameToken(@SuppressWarnings("OptionalUsedAsFieldOrParameterType") Optional<EndGameToken> endGameToken) {
@@ -70,8 +73,9 @@
 
     /**
      * //TODO java doc is to be written
-     * @author Edoardo Margarini
+     *
      * @return
+     * @author Edoardo Margarini
      */
     protected Tile[][] getSpaces() {
         return spaces;
@@ -79,25 +83,28 @@
 
     /**
      * //TODO java doc is to be written
+     *
      * @author Edoardo Margarini
      */
-    protected void setSpace(@NotNull Coordinates coords, Tile tile){
-        spaces[coords.x()][coords.y()]=tile;
+    protected void setSpace(@NotNull Coordinates coords, Tile tile) {
+        spaces[coords.x()][coords.y()] = tile;
     }
 
     /**
      * //TODO java doc is to be written
+     *
+     * @return
      * @author Edoardo Margarini
-     * @return
      */
-    protected Bag getBag(){
+    protected Bag getBag() {
         return bag;
     }
 
     /**
      * //TODO java doc is to be written
-     * @author Edoardo Margarini
+     *
      * @return
+     * @author Edoardo Margarini
      */
     protected Optional<EndGameToken> getEndGameToken() {
         return endGameToken;
@@ -105,6 +112,7 @@
 
     /**
      * //TODO java doc is to be written
+     *
      * @author Edoardo Margarini
      */
     protected void refill() {
@@ -113,8 +121,8 @@
 
         for (int i = 0; i < ROW_LENGTH; i++)
             for (int j = 0; j < COLUMN_LENGTH; j++) {
-                if (spaces[i][j]== Tile.EMPTY) {
-                    Tile t=bag.draw();
+                if (spaces[i][j] == Tile.EMPTY) {
+                    Tile t = bag.draw();
                     spaces[i][j] = t;
                 }
             }
@@ -122,16 +130,17 @@
 
     /**
      * //TODO java doc is to be written
-     * @author Edoardo Margarini
+     *
      * @param selection
      * @return
+     * @author Edoardo Margarini
      */
     protected List<Tile> selectTiles(List<Coordinates> selection) {
 
         List<Tile> list = new LinkedList<>();
 
-        if(checkSelection(selection)) {
-            for(Coordinates e : selection)
+        if (checkSelection(selection)) {
+            for (Coordinates e : selection)
                 list.add(spaces[e.x()][e.y()]);
 
             emptyTiles(selection);
@@ -142,53 +151,54 @@
 
     /**
      * A series of checks that allow to know if a move is allowed
-     * @author Edoardo Margarini
+     *
      * @param selection is a list of coords of the board
      * @return true if every check has positive feedback, false if one check has negative feedback
-     * */
+     * @author Edoardo Margarini
+     */
     protected boolean checkSelection(@NotNull List<Coordinates> selection) {
         //checks the player has chosen max 3 tiles
-        if(selection.size()>3)
+        if (selection.size() > 3)
             return false;
 
         //checks the player has chosen available tiles (!=null !=Tile.EMPTY)
-        for(Coordinates e : selection) {
-            if(spaces[e.x()][e.y()]==null || spaces[e.x()][e.y()]==Tile.EMPTY)
+        for (Coordinates e : selection) {
+            if (spaces[e.x()][e.y()] == null || spaces[e.x()][e.y()] == Tile.EMPTY)
                 return false;
         }
 
         //checks the player has chosen tiles that has a free adjacent
-        for(Coordinates e : selection) {
-            if(!adjacentTile(e).contains(null) && !adjacentTile(e).contains(Tile.EMPTY))
+        for (Coordinates e : selection) {
+            if (!adjacentTile(e).contains(null) && !adjacentTile(e).contains(Tile.EMPTY))
                 return false;
         }
 
         //checks the player has chosen 1 single tile, in this case all the tests made are sufficient
-        if(selection.size()==1)
+        if (selection.size() == 1)
             return true;
 
         //checks the player has chosen tiles in column or in row
-        List<Integer> listX=new ArrayList<>();
-        List<Integer> listY=new ArrayList<>();
-        for(Coordinates e : selection){
+        List<Integer> listX = new ArrayList<>();
+        List<Integer> listY = new ArrayList<>();
+        for (Coordinates e : selection) {
             listX.add(e.x());
             listY.add(e.y());
         }
-        if(!listX.stream().allMatch(s -> s.equals(listX.get(0))) && !listY.stream().allMatch(s -> s.equals(listY.get(0))))
+        if (!listX.stream().allMatch(s -> s.equals(listX.get(0))) && !listY.stream().allMatch(s -> s.equals(listY.get(0))))
             return false;
 
 
         List<Integer> list;
 
-        if(Objects.equals(listX.get(0), listX.get(1)))
+        if (Objects.equals(listX.get(0), listX.get(1)))
             list = listY;
         else
             list = listX;
 
         Collections.sort(list);
 
-        for(int i=0;i<list.size();i++){
-            if(list.get(i)!=list.get(0)+i)
+        for (int i = 0; i < list.size(); i++) {
+            if (list.get(i) != list.get(0) + i)
                 return false;
         }
 
@@ -197,23 +207,25 @@
 
     /**
      * Deletes tiles from board, they are ready to be placed on a shelf
+     *
+     * @param selection is a list of coords of the board
      * @author Edoardo Margarini
-     * @param selection is a list of coords of the board
      */
     private void emptyTiles(@NotNull List<Coordinates> selection) {
-        selection.forEach((e)->spaces[e.x()][e.y()]=Tile.EMPTY);
+        selection.forEach((e) -> spaces[e.x()][e.y()] = Tile.EMPTY);
     }
 
     /**
      * Checks if the board is refillable
-     * @author Edoardo Margarini
+     *
      * @return true or false
+     * @author Edoardo Margarini
      */
     protected boolean checkToRefill() {
 
-        for(int i = 0; i < ROW_LENGTH; i++)
-            for(int j = 0; j < COLUMN_LENGTH; j++) {
-                if(!isCompletelyFree(new Coordinates(i, j)) && spaces[i][j]!=null && spaces[i][j]!=Tile.EMPTY)
+        for (int i = 0; i < ROW_LENGTH; i++)
+            for (int j = 0; j < COLUMN_LENGTH; j++) {
+                if (!isCompletelyFree(new Coordinates(i, j)) && spaces[i][j] != null && spaces[i][j] != Tile.EMPTY)
                     return false;
             }
 
@@ -223,9 +235,10 @@
 
     /**
      * Checks if a tile has no other adjacent tiles
-     * @author Edoardo Margarini
+     *
      * @param coords of a space in the board
      * @return true or false
+     * @author Edoardo Margarini
      */
     private boolean isCompletelyFree(Coordinates coords) {
         return adjacentTile(coords).contains(Tile.EMPTY) ||
@@ -234,42 +247,44 @@
 
     /**
      * Adjacent tile
-     * @author Edoardo Margarini
+     *
      * @param coords of a space in the board
      * @return a list of adjacent Tile
+     * @author Edoardo Margarini
      */
     private @NotNull List<Tile> adjacentTile(@NotNull Coordinates coords) {
 
         List<Tile> adjTile = new LinkedList<>();
 
-        if(coords.x()> ROW_LENGTH)
+        if (coords.x() > ROW_LENGTH)
             adjTile.add(null);
         else
-            adjTile.add(spaces[coords.x()+1][coords.y()]);
+            adjTile.add(spaces[coords.x() + 1][coords.y()]);
 
-        if(coords.x()<1)
+        if (coords.x() < 1)
             adjTile.add(null);
         else
-            adjTile.add(spaces[coords.x()-1][coords.y()]);
+            adjTile.add(spaces[coords.x() - 1][coords.y()]);
 
-        if(coords.y()> COLUMN_LENGTH)
+        if (coords.y() > COLUMN_LENGTH)
             adjTile.add(null);
         else
-            adjTile.add(spaces[coords.x()][coords.y()+1]);
+            adjTile.add(spaces[coords.x()][coords.y() + 1]);
 
-        if(coords.y()<1)
+        if (coords.y() < 1)
             adjTile.add(null);
         else
-            adjTile.add(spaces[coords.x()][coords.y()-1]);
+            adjTile.add(spaces[coords.x()][coords.y() - 1]);
 
         return adjTile;
     }
 
     /**
      * //TODO java doc is to be written
-     * @author Edoardo Margarini
+     *
      * @param coordinates
      * @return
+     * @author Edoardo Margarini
      */
     protected Tile getTileInBoard(@NotNull Coordinates coordinates) {
         return spaces[coordinates.x()][coordinates.y()];
@@ -277,6 +292,7 @@
 
     /**
      * Puts all the tiles of the board in the bag
+     *
      * @author Edoardo Margarini
      */
     private void emptyBoardInBag() {
